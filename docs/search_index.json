[["index.html", "rxode2用户手册中文版", " rxode2用户手册中文版 英文原版作者：马修·菲德勒(Matthew Fidler)，梅丽莎·哈洛(Melissa Hallow)，Wang Wenping 英文原版发布日期：2022-11-07 简体中文翻译作者：付永超(Fu Yongchao) 中文原版发布日期：2023-06-09 "],["第一章导言.html", "第一章导言", " 第一章导言 欢迎来到rxode2用户指南;rxode2是一个R添加包，用于从基于常微分方程(ode,Ordinary Differential Equation)的模型中求解和模拟(不包括基于观测数据估计模型参数的功能)。这些模型将rxode2迷你语言转换为C并创建一个编译的dll以进行快速求解。使用rxode2求解ODE有几个关键部分： rxode2()创建用于快速求解ODE的C代码 与莱布尼茨符号相关的简单语法(第6章)。 事件数据，可以是： 一个NONMEM或deSolve兼容的数据框(第 7章)，或 使用et()或EventTable()创建事件，用于快速的进行模拟 (第11章) 可以通过添加时变或添加单个协变量(iCov=根据需要)来扩展数据帧 rxSolve()它使用初始条件和参数来求解方程组以进行预测 对于多个个体数据，这或可以并行化的方式运行 对于单个个体，输出数据帧自适应的 协方差和其他不确定性指标可用于模拟求解 虽然这是用户指南，但您可以访问其他地方寻求帮助： rxode2由github托管的pkgdown页面 rxode2教程(可在RStudio 1.3+的教程中访问) rxode2 github中的论坛 本书于2022年11月7日20：04：52与rxode2版本2.0.11通过GitHub操作自动组装。 "],["第二章作者和致谢.html", "第二章作者和致谢 2.1作者 2.2贡献者 2.3RxODE致谢：", " 第二章作者和致谢 2.1作者 Matthew L. Fidler(核心团队/开发人员/手册) Melissa Hallow(教程作者) Wenping Wang(核心团队/开发者) 2.2贡献者 ZufarMulyukov - 编写了rxShiny()的初始版本rxShiny()并从Matthew Fidler进行了修改 Alan Hindmarsh - Lsoda的作者 Awad H. Al - Mohy - Al-Mohy矩阵指数作者 Ernst Hairer - dop853作者 Gerhard Wanner - dop853作者 Goro Fuji - Timsort作者 Hadley Wickham - RxODE中的原始findLhs的作者，也是. s3Register的原始作者(允许任何人使用，两者都由Matthew Fidler修改) Jack Donarra - LApack作者 Linda Petzold - LSODA Martin Maechler - expm作者，使用那里的例程进行归纳线性化 Morwenn - Timsort作者 Nicholas J. Higham - Al-mohy矩阵指数的作者 Roger B. Sidje - expokit矩阵指数作者 Simon Frost - liblsoda的线程安全C实现 Kevin Ushey - 快速因子的原作者，由Matthew Filder修改 Yu Feng - 线程安全liblsoda Matt Dowle - forder主要作者(版本由Matthew Fidler修改以允许不同类型的线程并排除分组) Cleve Moler - LApack作者 David Cooley - fast_factor的作者，该fast_factor已被修改，现在使用RxODE快速创建ID的因子，而无需像R那样对其进行排序 Drew Schmidt - 指数矩阵实用工具编辑器的作者，取自R包expm Arun Srinivasan - forder第二作者(版本由Matthew Fidler修改以允许不同类型的线程、索引和排除分组) 2.3RxODE致谢： Sherwin Sy - 基于体重的剂量示例 Justin Wilkins - 文档更新、徽标和测试 Emma Schwager - R IJK distribution作者 J Coligne - dop853 fortran作者 Bill Denney - 文档更新、手册和次要bug修复 Tim Waterhouse - 修复了一个bug与mac工作目录 Richard Upton - 帮助解决ADVAN linCmt()解决方案 Dirk Eddelbuettel - 对需要R严格标头的Rcpp更改进行了一些修复 Ross Ihaka - R作者 Robert Gentleman - R作者 R核心团队 - R作者 "],["第三章相关-r-包.html", "第三章相关 R 包 3.1 常微分方程求解 3.2已求解的PK系统", " 第三章相关 R 包 3.1 常微分方程求解 这里简要的将rxode2和其他的定量药理学ODE(Ordinary Differential Equation,常微分方程)求解器R添加包做了比较。 这里罗列了一些用于求解微分方程的R添加包。其中最受欢迎的是deSolve。 然而，对于定量药理学特异性的ODE求解器， 除了rxode2 以外在 CRAN 上发布的只有 2 个R添加包。它们每个都使用编译后的代码来更快地求解 ODE。 mrgsolve，它使用 C++ lsoda 求解器求解ODE系统。用户需要使用由R/C++混合编写的代码创建mrgsolve所使用的模型文件，用户编写的模型会被mrgsolve在执行时转换为C++代码后求解。 相比之下，rxode2具有一个类似R语言风格的迷你语言，可以被解析为 求解ODE系统的C代码。 与rxode2不同，mrgsolve目前不支ODE系统的符号操作，如自动雅可比计算或前向灵敏度计算(目前rxode2支持这一点并且这是nlmixr2的FOCEi算法的基础) dMod，它使用一种独特的语法来创建“反应(reactions)”。这些反应创建底层的ODEs，然后为编译后的deSolve模型创建c代码。 相比之下，rxode2在较低级别定义了ODE系统。rxode2的迷你语言的解析来自C，而dMod的解析来自R。 与rxode2一样，dMod支持ODE系统的符号操作，并且支持计算系统的前向灵敏度( forward sensitivities)和伴随灵敏度( adjoint sensitivities)。 与rxode2不同，dMod不是线程安全的，因为deSolve还不是线程安全的。 PKPDsim，它用类似R语言的语法风格定义模型，并将系统转换为已编译的代码。【译者注：此添加包未在CRAN上发布，仅发布在了github上】 像mrgsolve一样，PKPDsim目前不支持ODE系统的符号操作。 PKPDsim不是线程安全的。 开放的定量药理学开源社区相当友好，rxode2维护者与列出的所有ODE求解器的定量药理学项目都有积极的互动。 3.2已求解的PK系统 rxode2支持带梯度1-3房室模型(使用Stan 数学的自动微分)。目前，它使用与PKADVAN相同的方程来允许时变协变量。 在rxode2中，用户可以混合使用ODE和已求解的系统(solved systems)。【译者注：类似于NONMEM中的ADVANs模型，Phoenix NLME中的勾选了“Closed-form”选项后的内置模型，这类模型的好处时已经预先编译处理好了，相对于ODE运行的更快，缺点时已经编译好了不能修改已有的模型。而当前rxode2特意描述了它支持混合使用ODE和已求解的系统，相当于用于可以在已有的预编译的模型上添加新的ODE进行扩展，从而兼具快速与灵活这两个特性】 3.2.1以下在CRAN上的软件包含有已求解的PK系统 mrgsolve目前内置了1-2房室(多指数模型)模型。已求解的系统和ode目前不能混合。 pmxTools目前内置了1-3房室(超级定位)模型。这是一个纯r实现。 PKPDsim使用“ADVAN”1-3解析，使用非叠加。 PKPDmodels有一个带梯度的一房室模型。 3.2.2非CRAN库中的程序包： PKADVAN提供了1-3房室模型使用非叠加。这允许时变协变量。 "],["第四章安装.html", "第四章安装 4.1开发版本", " 第四章安装 你可以使用下述命令从CRAN安装到rxode2的正式版本： install.packages(&quot;rxode2&quot;) 您可以使用下述命令安装rxode2的开发版本 devtools::install_github(&quot;nlmixr2/rxode2parse&quot;) devtools::install_github(&quot;nlmixr2/rxode2random&quot;) devtools::install_github(&quot;nlmixr2/rxode2et&quot;) devtools::install_github(&quot;nlmixr2/rxode2ll&quot;) devtools::install_github(&quot;nlmixr2/rxode2&quot;) 要使用rxode2构建模型，您需要一个可以工作的c编译器。要在rxode2中使用并行化线程求解，这个c编译器需要支持open-mp。 您可以使用下述命令检查R是否有可以使用的c编译器： ## install.packages(&quot;pkgbuild&quot;) pkgbuild::has_build_tools(debug = TRUE) 如果您没有工具链，您可以根据您使用的的平台按照下面信息进行设置： 4.0.1Windows 在windows中，您可以简单地使用install r命令来安装rtools： install.packages(&quot;installr&quot;) library(installr) install.rtools() 或者你也可以直接下载并安装 rtools。 4.0.2 Mac OSX 为了获得最快的速度，您需要启用OpenMP并使用该编译器编译rxode2。有各种各样的选择，关于这个的最新讨论可能是针对MacOS的data.table安装常见问答。 最后要记住的是rxode2使用的代码与原始的lsoda非常类似，这需要设置gfortran编译器和OpenMP编译器。 如果你要同时使用rxode2和nlmixr，并使用一台较旧的Mac电脑，我建议尝试以下方法： library(symengine) 如果这使您的R会话崩溃，那么二进制文件不适用于您的Mac电脑。为了能够运行nlmixr，您需要手动编译这个包。我将继续假设您的系统上安装了homebrew 。 在您的系统终端上，您需要安装依赖项来编译symengine： brew install cmake gmp mpfr libmpc 安装依赖后，您需要重新安装symengine： install.packages(&quot;symengine&quot;, type=&quot;source&quot;) library(symengine) 4.0.3Linux 要在linux上安装，请确保使用发行版的包管理器安装gcc(支持openmp)和gfortran。 4.1开发版本 由于rxode2的开发版本使用StanHeaders，您需要确保您的编译器已设置为支持C++14，如rstan设置页面所属。 对于R 4.0，我认为这不再需要修改windows工具链(因此设置起来要容易得多)。 正确设置C++工具链后，你可以使用下述命从GitHub安装开发版本： # install.packages(&quot;devtools&quot;) devtools::install_github(&quot;nlmixr2/rxode2parse&quot;) devtools::install_github(&quot;nlmixr2/rxode2random&quot;) devtools::install_github(&quot;nlmixr2/rxode2et&quot;) devtools::install_github(&quot;nlmixr2/rxode2ll&quot;) devtools::install_github(&quot;nlmixr2/rxode2&quot;) "],["第五章入门.html", "第五章入门 5.1指定ODE参数和初始条件 5.2在rxode2中指定给药和采样 5.3求解ODE", " 第五章入门 模型方程可以通过文本字符串、单独的模型文件或R表达式来指定。微分方程和代数方程都是允许的。微分方程由d/dt(var_name) =指定。不同方程间可以用英文分号分隔开。 加载rxode2包并编译模型： library(rxode2) #&gt; rxode2 2.0.11 using 4 threads (see ?getRxThreads) mod1 &lt;- rxode2({ C2 &lt;- centr/V2; C3 &lt;- peri/V3; d/dt(depot) &lt;- -KA*depot; d/dt(centr) &lt;- KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) &lt;- Q*C2 - Q*C3; d/dt(eff) &lt;- Kin - Kout*(1-C2/(EC50+C2))*eff; }) 5.1指定ODE参数和初始条件 模型参数可以定义为命名向量，向量中参数的名称必须是ODE模型中参数的超集【译者注：即ODE中的参数是向量中参数名称的子集】，向量内参数的顺序并不重要。 theta &lt;- c(KA=2.94E-01, CL=1.86E+01, V2=4.02E+01, # central Q=1.05E+01, V3=2.97E+02, # peripheral Kin=1, Kout=1, EC50=200) # effects 初始条件(ICs,Initial conditions)也可以通过向量定义。如果未指定元素，则假定房室的初始条件为零。 inits &lt;- c(eff=1) 如果要在模型中指定初始条件，可以添加： eff(0) = 1 5.2在rxode2中指定给药和采样 rxode2提供了一种简单且非常灵活的方式，通过生成事件表的函数来指定给药(Dosing)和采样(Sampling) 。首先，通过”eventTable()“函数生成一个空的事件表： ev &lt;- eventTable(amount.units=&#39;mg&#39;, time.units=&#39;hours&#39;) 接下来，使用add.dosing()和add.sampling()函数 EventTable对象来指定给药(数量、频率和/或时间等)和对系统状态进行采样观测的时间。这些函数可以多次调用以指定更复杂的给药或取样方案。在这里，使用下述代码通过这些函数指定10mg BID给药5天，随后20mg QD给药 5天： ev$add.dosing(dose=10000, nbr.doses=10, dosing.interval=12) ev$add.dosing(dose=20000, nbr.doses=5, start.time=120, dosing.interval=24) ev$add.sampling(0:240) 如果您愿意，您也可以使用mattigr管道操作符%&gt;%来执行此操作 ev &lt;- eventTable(amount.units=&quot;mg&quot;, time.units=&quot;hours&quot;) %&gt;% add.dosing(dose=10000, nbr.doses=10, dosing.interval=12) %&gt;% add.dosing(dose=20000, nbr.doses=5, start.time=120, dosing.interval=24) %&gt;% add.sampling(0:240) 函数get.dosing()和get.sampling()可用于从事件表中检索信息。 head(ev$get.dosing()) #&gt; id low time high cmt amt rate ii addl evid ss dur #&gt; 1 1 NA 0 NA (default) 10000 0 12 9 1 0 0 #&gt; 2 1 NA 120 NA (default) 20000 0 24 4 1 0 0 head(ev$get.sampling()) #&gt; id low time high cmt amt rate ii addl evid ss dur #&gt; 1 1 NA 0 NA (obs) NA NA NA NA 0 NA NA #&gt; 2 1 NA 1 NA (obs) NA NA NA NA 0 NA NA #&gt; 3 1 NA 2 NA (obs) NA NA NA NA 0 NA NA #&gt; 4 1 NA 3 NA (obs) NA NA NA NA 0 NA NA #&gt; 5 1 NA 4 NA (obs) NA NA NA NA 0 NA NA #&gt; 6 1 NA 5 NA (obs) NA NA NA NA 0 NA NA 您可能会注意到，这些与NONMEM事件表类似;如果您更熟悉NONMEM数据和事件，您可以直接将它们与事件表函数et一起使用 ev &lt;- et(amountUnits=&quot;mg&quot;, timeUnits=&quot;hours&quot;) %&gt;% et(amt=10000, addl=9,ii=12,cmt=&quot;depot&quot;) %&gt;% et(time=120, amt=2000, addl=4, ii=14, cmt=&quot;depot&quot;) %&gt;% et(0:240) # Add sampling 您可以从上面的代码中看到，您可以将给药分配到rxode2模型中已命名的房室。这种与NONMEM的轻微偏差可以减少房室重新编号的需要。 这些事件也可以通过rbind、c、seq和rep组合和扩展(到多个体事件和复杂的方案)。有关使用rxode2创建复杂给药方案的更多信息，请参阅rxode2事件部分。 5.3求解ODE 现在可以通过调用模型对象的run或solve函数求解。将模型中所有变量的模拟结果存储在输出矩阵x中。 x &lt;- mod1$solve(theta, ev, inits); knitr::kable(head(x)) time C2 C3 depot centr peri eff 0 0.00000 0.0000000 10000.000 0.000 0.0000 1.000000 1 44.37555 0.9198298 7452.765 1783.897 273.1895 1.084664 2 54.88296 2.6729825 5554.370 2206.295 793.8758 1.180825 3 51.90343 4.4564927 4139.542 2086.518 1323.5783 1.228914 4 44.49738 5.9807076 3085.103 1788.795 1776.2702 1.234610 5 36.48434 7.1774981 2299.255 1466.670 2131.7169 1.214742 您也可以求解这模型并创建一个rxode2数据框： x &lt;- mod1 %&gt;% rxSolve(theta, ev, inits); x #&gt; ── Solved rxode2 object ── #&gt; ── Parameters (x$params): ── #&gt; V2 V3 KA CL Q Kin Kout EC50 #&gt; 40.200 297.000 0.294 18.600 10.500 1.000 1.000 200.000 #&gt; ── Initial Conditions (x$inits): ── #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; ── First part of data (object): ── #&gt; # A tibble: 241 × 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 1 #&gt; 2 1 44.4 0.920 7453. 1784. 273. 1.08 #&gt; 3 2 54.9 2.67 5554. 2206. 794. 1.18 #&gt; 4 3 51.9 4.46 4140. 2087. 1324. 1.23 #&gt; 5 4 44.5 5.98 3085. 1789. 1776. 1.23 #&gt; 6 5 36.5 7.18 2299. 1467. 2132. 1.21 #&gt; # … with 235 more rows 这将返回一个修改后的数据框。您可以在下图中看到房室中的数值： library(ggplot2) plot(x,C2) + ylab(&quot;Central Concentration&quot;) 或者， plot(x,eff) + ylab(&quot;Effect&quot;) 请注意，标签会自动使用初始事件表中的单位进行标记。rxode2提取units来标记绘图(如果它们存在)。 "],["第六章rxode2语法.html", "第六章rxode2语法 6.1示例 6.2语法 6.3逻辑运算符 6.4cmt()改变状态的房室编号", " 第六章rxode2语法 本章节简要描述了用于定义模型的语法，rxode2将把这些模型转换为r可调用的编译代码。它还描述了R和rxode2模型指定之间变量的通信。 6.1示例 # An rxode2 model specification (this line is a comment). if(comed==0){ # concomitant medication (con-med)? F = 1.0; # full bioavailability w.o. con-med } else { F = 0.80; # 20% reduced bioavailability } C2 = centr/V2; # concentration in the central compartment C3 = peri/V3; # concentration in the peripheral compartment # ODE describing the PK and PD d/dt(depot) = -KA*depot; d/dt(centr) = F*KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; 6.2语法 一个rxode2模型描述由一个或多个语句组成，不同语句间可在句尾可选地添加分号;进行分隔，和可选添加注释(注释由#开始和在行尾结束)。 语句块是由大括号{...}分隔的一组语句。 语句可以是赋值、条件if/else if/else、while循环(可以通过break退出)、特殊语句或打印语句(用于调试/测试)。 赋值语句可以是： 简单赋值，其中赋值符左手边是标识符(即变量) 对特殊的时间导数赋值，其中赋值符左手边指定相应状态变量(房室)中的数量相对于时间的变化，例如，d/dt(depot)： 对特殊的初始条件赋值，其中赋值符左手边指定被指定的初始条件的房室， 例如depot(0) = 0 对特殊的模型事件的修改，包括生物利用度 (f(depot)=1)，滞后时间(alag(depot)=0)，使用输注速率参数化 (rate(depot)=2)和使用输注持续时长参数化(dur(depot)=2)。在rxode2事件部分中可以找到这些模型特征的一个示例，以及用于描述输注参数化方式的事件规范和rxode2数据规范。 特殊更改点语法或模型时间。这些模型时间是由mtime(var)=time指定 特殊的雅可比导数复制，其中赋值符左手边指定房室ode相相对于某个变量的变化。例如，如果d/dt(y) = dy，则为此使用Jacobian 房室可以指定为df(y)/dy(dy) = 1。对于非常刚性的ODE系统，获得解或指定雅可比矩阵可能会有一些好处。然而，对于我们使用LSODA尝试的几个刚性系统，这实际上略微减慢了求解速度。 注意赋值可以通过=、&lt;-或~来完成。 使用~运算符赋值时，不会输出简单赋值和时间导数赋值。 特别声明可以是： 房室声明语句，它可以改变默认的给药房室和假设的房室数，以及在最后添加额外的房室名(对多终点nlmixr模型有用);这些是由cmt(compartmentName)指定 参数声明语句, 它可以确保输入参数按一定的顺序排列，而不是按解析的顺序排列参数。这对于在使用2个不同的ODE模型时保持参数顺序相同非常有用。它们由 param(par1, par2,...)指定 一个示例模型如下所示: # simple assignment C2 = centr/V2; # time-derivative assignment d/dt(centr) = F*KA*depot - CL*C2 - Q*C2 + Q*C3; 赋值和if语句中的表达式可以是数值或逻辑值。 数字表达式可以包括以下数字运算符+, -, *, /, ^以及C或R数学库中定义的数学函数(例如fabs、exp、log、sin、abs)。 您还可以访问R数学库中的R函数， 就像log gamma函数的lgammafn一样。 rxode2语法区分大小写，即ABC与abc、Abc、ABc等是不同。 6.2.1 标识符 与R一样，标识符(变量名)可能由一个或多个字母数字， 下划线_或句点.字符组成，但第一个字符不能是数字或下划线_。 模型描述中的标识符可以参考： 动态系统中的状态变量(例如，药代动力学模型中的房室)。 隐含输入变量t(时间)、tlast(最后时间点)和 podo(口服剂量，在未记录的吸收过转移室型中)。 特殊常数如pi或 R的预定义常量。 模型参数(例如ka吸收率、CL清除率等) 其他，作为模型描述的一部分由赋值符创建的;这些被称为LHS(左手边)变量。 目前rxode2建模语言只识别系统状态变量和“参数”，因此，需要从R传递到ODE模型的任何值(例如，age)都应该在rxSolve()的params参数中传递，或者在提供的事件数据集中传递。 在rxode2事件表中有某些变量名。 为避免混淆，以下事件表相关项目不能 被赋值或用作状态，但可以在rxode2代码中访问： cmt dvid addl ss rate id 但是，以下变量不能在模型描述中使用： evid ii 有时rxode2会生成反馈给rxode2的变量。 类似地，nlmixr生成一些变量，用于nlmixr估计和模拟。这些变量以 rx或nlmixr前缀。为避免任何问题，建议不要为变量使用rx或nlmixr 前缀。 6.3逻辑运算符 逻辑运算符支持标准的R运算符==、!= &gt;= &lt;= &gt;和&lt;。像R一样，它们可以用在if()或while() 语句，ifelse()表达式。此外，它们可以在标准的赋值中。例如，以下内容有效： cov1 = covm*(sexf == &quot;female&quot;) + covm*(sexf != &quot;female&quot;) 请注意，您还可以在比较中使用字符表达式。 这种便利是有代价的，因为字符比较比数值表达式慢。与R不同，as.numeric或 as.integer对于这些逻辑语句不仅不需要，而且如果您尝试使用这些函数，将导致语法错误。 6.4cmt()改变状态的房室编号 使用cmt()语句可以更改房室的顺序。要了解cmt()可以做什么，您需要了解rxode2如何编号房室。 下面是rxode2如何编号房室的示例 6.4.1rxode2如何编号房室 rxode2在解析时自动分配房室编号。例如，对于Mavoglurant PBPK模型，可以使用以下模型： library(rxode2) pbpk &lt;- rxode2({ KbBR = exp(lKbBR) KbMU = exp(lKbMU) KbAD = exp(lKbAD) CLint= exp(lCLint + eta.LClint) KbBO = exp(lKbBO) KbRB = exp(lKbRB) ## Regional blood flows # Cardiac output (L/h) from White et al (1968) CO = (187.00*WT^0.81)*60/1000; QHT = 4.0 *CO/100; QBR = 12.0*CO/100; QMU = 17.0*CO/100; QAD = 5.0 *CO/100; QSK = 5.0 *CO/100; QSP = 3.0 *CO/100; QPA = 1.0 *CO/100; QLI = 25.5*CO/100; QST = 1.0 *CO/100; QGU = 14.0*CO/100; # Hepatic artery blood flow QHA = QLI - (QSP + QPA + QST + QGU); QBO = 5.0 *CO/100; QKI = 19.0*CO/100; QRB = CO - (QHT + QBR + QMU + QAD + QSK + QLI + QBO + QKI); QLU = QHT + QBR + QMU + QAD + QSK + QLI + QBO + QKI + QRB; ## Organs&#39; volumes = organs&#39; weights / organs&#39; density VLU = (0.76 *WT/100)/1.051; VHT = (0.47 *WT/100)/1.030; VBR = (2.00 *WT/100)/1.036; VMU = (40.00*WT/100)/1.041; VAD = (21.42*WT/100)/0.916; VSK = (3.71 *WT/100)/1.116; VSP = (0.26 *WT/100)/1.054; VPA = (0.14 *WT/100)/1.045; VLI = (2.57 *WT/100)/1.040; VST = (0.21 *WT/100)/1.050; VGU = (1.44 *WT/100)/1.043; VBO = (14.29*WT/100)/1.990; VKI = (0.44 *WT/100)/1.050; VAB = (2.81 *WT/100)/1.040; VVB = (5.62 *WT/100)/1.040; VRB = (3.86 *WT/100)/1.040; ## Fixed parameters BP = 0.61; # Blood:plasma partition coefficient fup = 0.028; # Fraction unbound in plasma fub = fup/BP; # Fraction unbound in blood KbLU = exp(0.8334); KbHT = exp(1.1205); KbSK = exp(-.5238); KbSP = exp(0.3224); KbPA = exp(0.3224); KbLI = exp(1.7604); KbST = exp(0.3224); KbGU = exp(1.2026); KbKI = exp(1.3171); ##----------------------------------------- S15 = VVB*BP/1000; C15 = Venous_Blood/S15 ##----------------------------------------- d/dt(Lungs) = QLU*(Venous_Blood/VVB - Lungs/KbLU/VLU); d/dt(Heart) = QHT*(Arterial_Blood/VAB - Heart/KbHT/VHT); d/dt(Brain) = QBR*(Arterial_Blood/VAB - Brain/KbBR/VBR); d/dt(Muscles) = QMU*(Arterial_Blood/VAB - Muscles/KbMU/VMU); d/dt(Adipose) = QAD*(Arterial_Blood/VAB - Adipose/KbAD/VAD); d/dt(Skin) = QSK*(Arterial_Blood/VAB - Skin/KbSK/VSK); d/dt(Spleen) = QSP*(Arterial_Blood/VAB - Spleen/KbSP/VSP); d/dt(Pancreas) = QPA*(Arterial_Blood/VAB - Pancreas/KbPA/VPA); d/dt(Liver) = QHA*Arterial_Blood/VAB + QSP*Spleen/KbSP/VSP + QPA*Pancreas/KbPA/VPA + QST*Stomach/KbST/VST + QGU*Gut/KbGU/VGU - CLint*fub*Liver/KbLI/VLI - QLI*Liver/KbLI/VLI; d/dt(Stomach) = QST*(Arterial_Blood/VAB - Stomach/KbST/VST); d/dt(Gut) = QGU*(Arterial_Blood/VAB - Gut/KbGU/VGU); d/dt(Bones) = QBO*(Arterial_Blood/VAB - Bones/KbBO/VBO); d/dt(Kidneys) = QKI*(Arterial_Blood/VAB - Kidneys/KbKI/VKI); d/dt(Arterial_Blood) = QLU*(Lungs/KbLU/VLU - Arterial_Blood/VAB); d/dt(Venous_Blood) = QHT*Heart/KbHT/VHT + QBR*Brain/KbBR/VBR + QMU*Muscles/KbMU/VMU + QAD*Adipose/KbAD/VAD + QSK*Skin/KbSK/VSK + QLI*Liver/KbLI/VLI + QBO*Bones/KbBO/VBO + QKI*Kidneys/KbKI/VKI + QRB*Rest_of_Body/KbRB/VRB - QLU*Venous_Blood/VVB; d/dt(Rest_of_Body) = QRB*(Arterial_Blood/VAB - Rest_of_Body/KbRB/VRB); }) 如果您查看摘要，您可以看到rxode2赋值房室号的位置 summary(pbpk) #&gt; rxode2 2.0.11 model named rx_291007fc063b6ec76a6a1e59198481c3 model (✔ ready). #&gt; DLL: /home/matt/.cache/R/rxode2/rx_291007fc063b6ec76a6a1e59198481c3__.rxd/rx_291007fc063b6ec76a6a1e59198481c3_.so #&gt; NULL #&gt; #&gt; Calculated Variables: #&gt; [1] &quot;KbBR&quot; &quot;KbMU&quot; &quot;KbAD&quot; &quot;CLint&quot; &quot;KbBO&quot; &quot;KbRB&quot; &quot;CO&quot; &quot;QHT&quot; &quot;QBR&quot; #&gt; [10] &quot;QMU&quot; &quot;QAD&quot; &quot;QSK&quot; &quot;QSP&quot; &quot;QPA&quot; &quot;QLI&quot; &quot;QST&quot; &quot;QGU&quot; &quot;QHA&quot; #&gt; [19] &quot;QBO&quot; &quot;QKI&quot; &quot;QRB&quot; &quot;QLU&quot; &quot;VLU&quot; &quot;VHT&quot; &quot;VBR&quot; &quot;VMU&quot; &quot;VAD&quot; #&gt; [28] &quot;VSK&quot; &quot;VSP&quot; &quot;VPA&quot; &quot;VLI&quot; &quot;VST&quot; &quot;VGU&quot; &quot;VBO&quot; &quot;VKI&quot; &quot;VAB&quot; #&gt; [37] &quot;VVB&quot; &quot;VRB&quot; &quot;fub&quot; &quot;KbLU&quot; &quot;KbHT&quot; &quot;KbSK&quot; &quot;KbSP&quot; &quot;KbPA&quot; &quot;KbLI&quot; #&gt; [46] &quot;KbST&quot; &quot;KbGU&quot; &quot;KbKI&quot; &quot;S15&quot; &quot;C15&quot; #&gt; ── rxode2 Model Syntax ── #&gt; rxode2({ #&gt; KbBR = exp(lKbBR) #&gt; KbMU = exp(lKbMU) #&gt; KbAD = exp(lKbAD) #&gt; CLint = exp(lCLint + eta.LClint) #&gt; KbBO = exp(lKbBO) #&gt; KbRB = exp(lKbRB) #&gt; CO = (187 * WT^0.81) * 60/1000 #&gt; QHT = 4 * CO/100 #&gt; QBR = 12 * CO/100 #&gt; QMU = 17 * CO/100 #&gt; QAD = 5 * CO/100 #&gt; QSK = 5 * CO/100 #&gt; QSP = 3 * CO/100 #&gt; QPA = 1 * CO/100 #&gt; QLI = 25.5 * CO/100 #&gt; QST = 1 * CO/100 #&gt; QGU = 14 * CO/100 #&gt; QHA = QLI - (QSP + QPA + QST + QGU) #&gt; QBO = 5 * CO/100 #&gt; QKI = 19 * CO/100 #&gt; QRB = CO - (QHT + QBR + QMU + QAD + QSK + QLI + QBO + QKI) #&gt; QLU = QHT + QBR + QMU + QAD + QSK + QLI + QBO + QKI + QRB #&gt; VLU = (0.76 * WT/100)/1.051 #&gt; VHT = (0.47 * WT/100)/1.03 #&gt; VBR = (2 * WT/100)/1.036 #&gt; VMU = (40 * WT/100)/1.041 #&gt; VAD = (21.42 * WT/100)/0.916 #&gt; VSK = (3.71 * WT/100)/1.116 #&gt; VSP = (0.26 * WT/100)/1.054 #&gt; VPA = (0.14 * WT/100)/1.045 #&gt; VLI = (2.57 * WT/100)/1.04 #&gt; VST = (0.21 * WT/100)/1.05 #&gt; VGU = (1.44 * WT/100)/1.043 #&gt; VBO = (14.29 * WT/100)/1.99 #&gt; VKI = (0.44 * WT/100)/1.05 #&gt; VAB = (2.81 * WT/100)/1.04 #&gt; VVB = (5.62 * WT/100)/1.04 #&gt; VRB = (3.86 * WT/100)/1.04 #&gt; BP = 0.61 #&gt; fup = 0.028 #&gt; fub = fup/BP #&gt; KbLU = exp(0.8334) #&gt; KbHT = exp(1.1205) #&gt; KbSK = exp(-0.5238) #&gt; KbSP = exp(0.3224) #&gt; KbPA = exp(0.3224) #&gt; KbLI = exp(1.7604) #&gt; KbST = exp(0.3224) #&gt; KbGU = exp(1.2026) #&gt; KbKI = exp(1.3171) #&gt; S15 = VVB * BP/1000 #&gt; C15 = Venous_Blood/S15 #&gt; d/dt(Lungs) = QLU * (Venous_Blood/VVB - Lungs/KbLU/VLU) #&gt; d/dt(Heart) = QHT * (Arterial_Blood/VAB - Heart/KbHT/VHT) #&gt; d/dt(Brain) = QBR * (Arterial_Blood/VAB - Brain/KbBR/VBR) #&gt; d/dt(Muscles) = QMU * (Arterial_Blood/VAB - Muscles/KbMU/VMU) #&gt; d/dt(Adipose) = QAD * (Arterial_Blood/VAB - Adipose/KbAD/VAD) #&gt; d/dt(Skin) = QSK * (Arterial_Blood/VAB - Skin/KbSK/VSK) #&gt; d/dt(Spleen) = QSP * (Arterial_Blood/VAB - Spleen/KbSP/VSP) #&gt; d/dt(Pancreas) = QPA * (Arterial_Blood/VAB - Pancreas/KbPA/VPA) #&gt; d/dt(Liver) = QHA * Arterial_Blood/VAB + QSP * Spleen/KbSP/VSP + #&gt; QPA * Pancreas/KbPA/VPA + QST * Stomach/KbST/VST + QGU * #&gt; Gut/KbGU/VGU - CLint * fub * Liver/KbLI/VLI - QLI * Liver/KbLI/VLI #&gt; d/dt(Stomach) = QST * (Arterial_Blood/VAB - Stomach/KbST/VST) #&gt; d/dt(Gut) = QGU * (Arterial_Blood/VAB - Gut/KbGU/VGU) #&gt; d/dt(Bones) = QBO * (Arterial_Blood/VAB - Bones/KbBO/VBO) #&gt; d/dt(Kidneys) = QKI * (Arterial_Blood/VAB - Kidneys/KbKI/VKI) #&gt; d/dt(Arterial_Blood) = QLU * (Lungs/KbLU/VLU - Arterial_Blood/VAB) #&gt; d/dt(Venous_Blood) = QHT * Heart/KbHT/VHT + QBR * Brain/KbBR/VBR + #&gt; QMU * Muscles/KbMU/VMU + QAD * Adipose/KbAD/VAD + QSK * #&gt; Skin/KbSK/VSK + QLI * Liver/KbLI/VLI + QBO * Bones/KbBO/VBO + #&gt; QKI * Kidneys/KbKI/VKI + QRB * Rest_of_Body/KbRB/VRB - #&gt; QLU * Venous_Blood/VVB #&gt; d/dt(Rest_of_Body) = QRB * (Arterial_Blood/VAB - Rest_of_Body/KbRB/VRB) #&gt; }) 在此案例中，Venous_Blood被分配到房室15。 弄清楚这一点可能会很不方便，并且还会导致模拟或估计数据集中的房室重新编号。虽然通过名称指定房室很容易而且可能更清晰，但其他工具只支持房室编号。因此，有一种方法可以很容易地为房室编号，从而减少多个工具之间的数据修改。 6.4.2 使用cmt()预声明更改房室 要按您希望的顺序将房室添加到rxode2模型中，您只需要使用cmt预先声明这些房室。例如，将Venous_Blood和Skin分别指定为第一个和第二个房室是很简单的: pbpk2 &lt;- rxode2({ ## Now this is the first compartment, ie cmt=1 cmt(Venous_Blood) ## Skin may be a compartment you wish to dose to as well, ## so it is now cmt=2 cmt(Skin) KbBR = exp(lKbBR) KbMU = exp(lKbMU) KbAD = exp(lKbAD) CLint= exp(lCLint + eta.LClint) KbBO = exp(lKbBO) KbRB = exp(lKbRB) ## Regional blood flows # Cardiac output (L/h) from White et al (1968)m CO = (187.00*WT^0.81)*60/1000; QHT = 4.0 *CO/100; QBR = 12.0*CO/100; QMU = 17.0*CO/100; QAD = 5.0 *CO/100; QSK = 5.0 *CO/100; QSP = 3.0 *CO/100; QPA = 1.0 *CO/100; QLI = 25.5*CO/100; QST = 1.0 *CO/100; QGU = 14.0*CO/100; QHA = QLI - (QSP + QPA + QST + QGU); # Hepatic artery blood flow QBO = 5.0 *CO/100; QKI = 19.0*CO/100; QRB = CO - (QHT + QBR + QMU + QAD + QSK + QLI + QBO + QKI); QLU = QHT + QBR + QMU + QAD + QSK + QLI + QBO + QKI + QRB; ## Organs&#39; volumes = organs&#39; weights / organs&#39; density VLU = (0.76 *WT/100)/1.051; VHT = (0.47 *WT/100)/1.030; VBR = (2.00 *WT/100)/1.036; VMU = (40.00*WT/100)/1.041; VAD = (21.42*WT/100)/0.916; VSK = (3.71 *WT/100)/1.116; VSP = (0.26 *WT/100)/1.054; VPA = (0.14 *WT/100)/1.045; VLI = (2.57 *WT/100)/1.040; VST = (0.21 *WT/100)/1.050; VGU = (1.44 *WT/100)/1.043; VBO = (14.29*WT/100)/1.990; VKI = (0.44 *WT/100)/1.050; VAB = (2.81 *WT/100)/1.040; VVB = (5.62 *WT/100)/1.040; VRB = (3.86 *WT/100)/1.040; ## Fixed parameters BP = 0.61; # Blood:plasma partition coefficient fup = 0.028; # Fraction unbound in plasma fub = fup/BP; # Fraction unbound in blood KbLU = exp(0.8334); KbHT = exp(1.1205); KbSK = exp(-.5238); KbSP = exp(0.3224); KbPA = exp(0.3224); KbLI = exp(1.7604); KbST = exp(0.3224); KbGU = exp(1.2026); KbKI = exp(1.3171); ##----------------------------------------- S15 = VVB*BP/1000; C15 = Venous_Blood/S15 ##----------------------------------------- d/dt(Lungs) = QLU*(Venous_Blood/VVB - Lungs/KbLU/VLU); d/dt(Heart) = QHT*(Arterial_Blood/VAB - Heart/KbHT/VHT); d/dt(Brain) = QBR*(Arterial_Blood/VAB - Brain/KbBR/VBR); d/dt(Muscles) = QMU*(Arterial_Blood/VAB - Muscles/KbMU/VMU); d/dt(Adipose) = QAD*(Arterial_Blood/VAB - Adipose/KbAD/VAD); d/dt(Skin) = QSK*(Arterial_Blood/VAB - Skin/KbSK/VSK); d/dt(Spleen) = QSP*(Arterial_Blood/VAB - Spleen/KbSP/VSP); d/dt(Pancreas) = QPA*(Arterial_Blood/VAB - Pancreas/KbPA/VPA); d/dt(Liver) = QHA*Arterial_Blood/VAB + QSP*Spleen/KbSP/VSP + QPA*Pancreas/KbPA/VPA + QST*Stomach/KbST/VST + QGU*Gut/KbGU/VGU - CLint*fub*Liver/KbLI/VLI - QLI*Liver/KbLI/VLI; d/dt(Stomach) = QST*(Arterial_Blood/VAB - Stomach/KbST/VST); d/dt(Gut) = QGU*(Arterial_Blood/VAB - Gut/KbGU/VGU); d/dt(Bones) = QBO*(Arterial_Blood/VAB - Bones/KbBO/VBO); d/dt(Kidneys) = QKI*(Arterial_Blood/VAB - Kidneys/KbKI/VKI); d/dt(Arterial_Blood) = QLU*(Lungs/KbLU/VLU - Arterial_Blood/VAB); d/dt(Venous_Blood) = QHT*Heart/KbHT/VHT + QBR*Brain/KbBR/VBR + QMU*Muscles/KbMU/VMU + QAD*Adipose/KbAD/VAD + QSK*Skin/KbSK/VSK + QLI*Liver/KbLI/VLI + QBO*Bones/KbBO/VBO + QKI*Kidneys/KbKI/VKI + QRB*Rest_of_Body/KbRB/VRB - QLU*Venous_Blood/VVB; d/dt(Rest_of_Body) = QRB*(Arterial_Blood/VAB - Rest_of_Body/KbRB/VRB); }) 您可以在简单的打印输出中看到此更改 pbpk2 #&gt; rxode2 2.0.11 model named rx_8538903f734422ef88399de66a046870 model (✔ ready). #&gt; x$state: Venous_Blood, Skin, Lungs, Heart, Brain, Muscles, Adipose, Spleen, Pancreas, Liver, Stomach, Gut, Bones, Kidneys, Arterial_Blood, Rest_of_Body #&gt; x$params: lKbBR, lKbMU, lKbAD, lCLint, eta.LClint, lKbBO, lKbRB, WT, BP, fup #&gt; x$lhs: KbBR, KbMU, KbAD, CLint, KbBO, KbRB, CO, QHT, QBR, QMU, QAD, QSK, QSP, QPA, QLI, QST, QGU, QHA, QBO, QKI, QRB, QLU, VLU, VHT, VBR, VMU, VAD, VSK, VSP, VPA, VLI, VST, VGU, VBO, VKI, VAB, VVB, VRB, fub, KbLU, KbHT, KbSK, KbSP, KbPA, KbLI, KbST, KbGU, KbKI, S15, C15 前两个房室是Venous_Blood后面Skin。 6.4.3用cmt()将房室附加到模型 您还可以将“房室”附加到模型中。由于ODE求解内部结构，在定义所有微分方程之前，您不能将假的房室添加到模型中。 例如，这是合法的： ode.1c.ka &lt;- rxode2({ C2 = center/V; d / dt(depot) = -KA * depot d/dt(center) = KA * depot - CL*C2 cmt(eff); }) print(ode.1c.ka) #&gt; rxode2 2.0.11 model named rx_4caaa6b18411f9babd3e3aafb7840fd4 model (✔ ready). #&gt; $state: depot, center #&gt; $stateExtra: eff #&gt; $params: V, KA, CL #&gt; $lhs: C2 但是在所有微分方程之前定义的房室是不支持的;所以下面的模型： ode.1c.ka &lt;- rxode2({ cmt(eff); C2 = center/V; d / dt(depot) = -KA * depot d/dt(center) = KA * depot - CL*C2 }) 会出错： Error in rxModelVars_(obj) : Evaluation error: Compartment &#39;eff&#39; needs differential equations defined. "],["第七章rxode2事件.html", "第七章rxode2事件 7.1rxode2事件表 7.2单次给药/额外附加的给药 7.3输注给药 7.4稳态 7.5重置事件 7.6关闭房室 7.7经典的rxode2事件 7.8rxode2 &amp; nlmixr的数据集 7.9按使用类型描述的列 7.10特定数据集列的详细信息", " 第七章rxode2事件 7.1rxode2事件表 通常，rxode2事件表格遵循NONMEM数据集约定，但有以下例外: 房室数据项(cmt)可以是包含房室名称的字符串/因子 您可以关闭房室编号为负或“-cmt”的房室，其中cmt是房室的名称。 房室数据项(cmt)仍然可以是数字，房室的数量由模型中房室名称的外观来定义。这可能很繁琐，所以您可以通过在模型开始时使用cmt(cmtName)来更容易地指定房室编号。 额外的一列，dur可指定输注持续的时长; 生物利用度的变化将会改变输注速率rate，因为dur/amt在输入数据中是固定的。 类似地，当为输注指定rate/amt时，由于rate/amt在输入数据中是固定的，因此生物利用度将改变输液持续时间dur。 一些不常见的NONMEM列不被rxode2支持，如:pcmt, call。 支持的nonmems风格的事件(0:观测Observation, 1: 给药Dose, 2: 其他Other, 3: 重置Reset, 4: 重置+给药Reset+Dose)。支持的其他事件: evid = 5或替换事件;这会将用AMT列中指定的值替换房室的值。这等价于deSolve=replace。 evid = 6或倍增事件;这会将用AMT列中指定的值与房室的值相乘。这等价于deSolve=multiply。 evid = 7或者转移室模型/幻影事件。这将给药放入dose()函数中，并计算自上次给药以来的时间tad()，但实际上并没有将给药放入房室。这使得transit()函数可以很容易地应用于房室。 在数据表中以下的条目是合法的: 数据条目 意义 备注 iid 个体的标识符 可以是整数、因子、字符还是数字 time 个体的时间 每个时间都是数字 amt 给药药量 给药时值应为正数，观测时值应为0或NA rate 输注速度 当指定此项时，输注时长dur=amt/rate 当rate=-1，给药使用速率参数化;当rate=-2，给药使用持续时长参数化 dur 输注持续的时长 当指定此项时，输注速率rate=amt/dur evid 事件标识符 0=观察;1=给药;2=其他;3=重置;4=重置+给药;5=替换;6=倍数;7=转移室 cmt 房室 表示给药或观测事件所处的房室的名称 ss 稳态标志 0=非稳态;1=稳定状态;2=稳态+先前状态 ii 给药间隔 给药之间的间隔时间。 addl 额外附加的给药次数 额外附件的与当前给药相同的给药次数。 另外应注意: evid可以是经典的RxODE(描述在这里)，或也可以是上面描述的NONMEM风格的evid。 NONMEM的DV不是必需的;rxode2是一个ODE求解框架。 NONMEM的形状不是必需的，因为它是在EVID。 rxode2它可以接受deSolve兼容的数据框，而不是NONMEM-兼容的数据，。 当返回rxode2已求解的数据集时，根据求解器选项，您可能会看到一些额外的事件id (EVID): EVID = -1输注速率参数化，输注结束的时间(对应于rate= -1【译者注：见7.3节】） EVID = -2输注持续时长参数化，输注结束的时间(对应于rate= -2【译者注：见7.3节】） EVID = -10当指定零级输注速率时，输注速率结束的时间(对应于rate&gt; 0【译者注：见7.3节】） EVID = -20当指定零级输注速率时，输注持续时长结束的时间(对应于Dur &gt; 0【译者注：见7.3节】） Evid = 101,102,103，…这些对应于1，2，3模型事件时间(mtime）. 这些只能在使用adddose =TRUE和subsetNonmem=FALSE选项组合进行求解时访问。如果你想看到同经典的EVID等价的，你可以使用adddose =NA。 为了说明事件类型，我们将使用rxode2中原始的教程中的模型用于举例。 library(rxode2) ### Model from rxode2 tutorial m1 &lt;- rxode({ KA =2.94E-01; CL =1.86E+01; V2 =4.02E+01; Q =1.05E+01; V3 =2.97E+02; kin=1; Kout =1; EC50 =200; ### Added modeled bioavaiblity, duration and rate fdepot = 1; durDepot = 8; rateDepot = 1250; C2 = centr/V2; C3 = peri/V3; d/dt(depot) =-KA*depot; f(depot) = fdepot dur(depot) = durDepot rate(depot) = rateDepot d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; eff(0) = 1 }); 7.2单次给药/额外附加的给药 单次给药是rxode2中默认的给药类型，仅需要提供amt/dose。请注意，这使用了rxode2事件表中描述的便利函数et() ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12,until=24) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ── EventTable with 101 records ── #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 100 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 101 × 5 #&gt; time amt ii addl evid #&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 NA NA NA 0:Observation #&gt; 2 0 10000 12 2 1:Dose (Add) #&gt; 3 0.242 NA NA NA 0:Observation #&gt; 4 0.485 NA NA NA 0:Observation #&gt; 5 0.727 NA NA NA 0:Observation #&gt; 6 0.970 NA NA NA 0:Observation #&gt; 7 1.21 NA NA NA 0:Observation #&gt; 8 1.45 NA NA NA 0:Observation #&gt; 9 1.70 NA NA NA 0:Observation #&gt; 10 1.94 NA NA NA 0:Observation #&gt; # … with 91 more rows 【译者注：因为上面的代码全是输出的注释，所以虽然是代码，这次也对上述内容进行下翻译，并同时提供翻译和未翻译版，便于读者理解，下文为对上文代码的翻译】 #&gt;── 事件表，其中包含有101条记录 ── #&gt;1个给药记录(参见x$get.dosing();可使用add.dosing #&gt;或et添加) #&gt;100次观测(参见x$get.samping();可使用add.Samples #&gt;或et添加) #&gt;addl列中的多次给药，可使用x$Expand()展开; #&gt;或etExpand(X) #&gt;── 第一部分 关于x： ── #&gt; #A Tibble：101×5 #&gt; 时间 药量 给药间隔 附加给药次数 事件标志 #&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt;1 0 NA NA NA 0：观测 #&gt;2 0 10000 12 2 1：给药(及额外附加) #&gt;3 0.242 NA NA NA 0：观测 #&gt;4 0.485 NA NA NA 0：观测 #&gt;5 0.727 NA NA NA 0：观测 #&gt;6 0.970 NA NA NA 0：观测 #&gt;7 1.21 NA NA NA 0：观测 #&gt;8 1.45 NA NA NA 0：观测 #&gt;9 1.70 NA NA NA 0：观测 #&gt;10 1.94 NA NA NA 0：观测 #&gt; #…后续还有了91行输出内容 rxSolve(m1, ev) %&gt;% plot(C2) + xlab(&quot;Time&quot;) 7.3输注给药 rxode2支持几种不同类型的输注实现形式: 已知输注速率的输注(rate）【译者注：常见于已知道输注速率的静脉输液;此时应在事件表中给出rate，并且rate的值应大于0】 已知输注时长的输注(dur）【译者注：常见于已知道输注持续时长的静脉输液;此时应在事件表中给出dur，并且dur的值应大于0】 需要估计输注速率的输注(零级速率吸收)【译者注：常见于将吸收处理为零级速率吸收，并需要估计吸收的零级速率常数;此时应在事件表中给出rate，并且rate的值应为-1】 需要估计输注时长的输注(零级速率吸收)【译者注：常见于将吸收处理为零级速率吸收，并需要估计吸收的持续的时长;此时应在事件表中给出rate，并且rate的值应为-2】 【译者注：对于0级速率吸收，模型参数化时存在4种形式，对应上述的4中实现形式：1人为可以控制的0级吸收（比如静脉输液），并且在数据中给出吸收速率;2人为可以控制的0级吸收（比如静脉输液），并且在数据中给出吸收持续的时长;3被近似认为是0级速率吸收，但仅知道药量，并需要估计吸收的0级速率常数;4被近似认为是0级速率吸收，但仅知道药量，并需要估计吸收持续的时长;】 7.3.1已知输注速率或输注时长的输注 下一种类型的事件是输注入;有两种方法可以指定输注;第一种是dur关键字。 一个例子是: ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12,until=24, dur=8) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ── EventTable with 101 records ── #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 100 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 101 × 6 #&gt; time amt ii addl evid dur #&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; [h] #&gt; 1 0 NA NA NA 0:Observation NA #&gt; 2 0 10000 12 2 1:Dose (Add) 8 #&gt; 3 0.242 NA NA NA 0:Observation NA #&gt; 4 0.485 NA NA NA 0:Observation NA #&gt; 5 0.727 NA NA NA 0:Observation NA #&gt; 6 0.970 NA NA NA 0:Observation NA #&gt; 7 1.21 NA NA NA 0:Observation NA #&gt; 8 1.45 NA NA NA 0:Observation NA #&gt; 9 1.70 NA NA NA 0:Observation NA #&gt; 10 1.94 NA NA NA 0:Observation NA #&gt; # … with 91 more rows 【译者注：因为上面的代码全是输出的注释，所以虽然是代码，这次也对上述内容进行下翻译，并同时提供翻译和未翻译版，便于读者理解，下文为对上文代码的翻译】 #&gt;── 事件表，其中包含有101条记录 ── #&gt;1个给药记录(参见x$get.dosing();可使用add.dosing #&gt;或et添加) #&gt;100次观测(参见x$get.samping();可使用add.Samples #&gt;或et添加) #&gt;addl列中的多次给药，可使用x$Expand()展开; #&gt;或etExpand(X) #&gt;── 第一部分 关于x： ── #&gt; #A Tibble：101×6 #&gt; 时间 药量 给药间隔 附加给药次数 事件标志 输注时长 #&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; [h] #&gt;1 0 NA NA NA 0：观测 NA #&gt;2 0 10000 12 2 1：给药(及额外附加) 8 #&gt;3 0.242 NA NA NA 0：观测 NA #&gt;4 0.485 NA NA NA 0：观测 NA #&gt;5 0.727 NA NA NA 0：观测 NA #&gt;6 0.970 NA NA NA 0：观测 NA #&gt;7 1.21 NA NA NA 0：观测 NA #&gt;8 1.45 NA NA NA 0：观测 NA #&gt;9 1.70 NA NA NA 0：观测 NA #&gt;10 1.94 NA NA NA 0：观测 NA #…后续还有了91行输出内容 rxSolve(m1, ev) %&gt;% plot(depot, C2) + xlab(&quot;Time&quot;) 另一种，它也可以由rate组件指定: ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12,until=24, rate=10000/8) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ── EventTable with 101 records ── #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 100 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 101 × 6 #&gt; time amt rate ii addl evid #&gt; [h] &lt;dbl&gt; &lt;rate/dur&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 NA NA NA NA 0:Observation #&gt; 2 0 10000 1250 12 2 1:Dose (Add) #&gt; 3 0.242 NA NA NA NA 0:Observation #&gt; 4 0.485 NA NA NA NA 0:Observation #&gt; 5 0.727 NA NA NA NA 0:Observation #&gt; 6 0.970 NA NA NA NA 0:Observation #&gt; 7 1.21 NA NA NA NA 0:Observation #&gt; 8 1.45 NA NA NA NA 0:Observation #&gt; 9 1.70 NA NA NA NA 0:Observation #&gt; 10 1.94 NA NA NA NA 0:Observation #&gt; # … with 91 more rows 【译者注：因为上面的代码全是输出的注释，所以虽然是代码，这次也对上述内容进行下翻译，并同时提供翻译和未翻译版，便于读者理解，下文为对上文代码的翻译】 #&gt;── 事件表，其中包含有101条记录 ── #&gt;1个给药记录(参见x$get.dosing();可使用add.dosing #&gt;或et添加) #&gt;100次观测(参见x$get.samping();可使用add.Samples #&gt;或et添加) #&gt;addl列中的多次给药，可使用x$Expand()展开; #&gt;或etExpand(X) #&gt;── 第一部分 关于x： ── #&gt; #A Tibble：101×6 #&gt; 时间 药量 速率 给药间隔 附加给药次数 事件标志 #&gt; [h] &lt;dbl&gt; &lt;rate/dur&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt;1 0 NA NA NA NA 0：观测 #&gt;2 0 10000 1250 12 2 1：给药(及额外附加) #&gt;3 0.242 NA NA NA NA 0：观测 #&gt;4 0.485 NA NA NA NA 0：观测 #&gt;5 0.727 NA NA NA NA 0：观测 #&gt;6 0.970 NA NA NA NA 0：观测 #&gt;7 1.21 NA NA NA NA 0：观测 #&gt;8 1.45 NA NA NA NA 0：观测 #&gt;9 1.70 NA NA NA NA 0：观测 #&gt;10 1.94 NA NA NA NA 0：观测 #…后续还有了91行输出内容 rxSolve(m1, ev) %&gt;% plot(depot, C2) + xlab(&quot;Time&quot;) 上述两种实现方式是相同的，除了生物利用度如何输注改变之外。 在使用rate建模的情况下，当生物利用度减小，输注时长也会减小，这与在NONMEM中一样。例如: rxSolve(m1, ev, c(fdepot=0.25)) %&gt;% plot(depot, C2) + xlab(&quot;Time&quot;) 同样，当增加生物利用度时，输注时长也会增加。 rxSolve(m1, ev, c(fdepot=1.25)) %&gt;% plot(depot, C2) + xlab(&quot;Time&quot;) 这种行为的基本原理是，rate和amt是由事件表指定的，因此，随着生物利用度的增加，唯一可以改变的是输注的持续时间。 与指定rate类似，如果您在事件表中指定amt和dur组件，生物利用度变化也会影响输注速率rate。 ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12,until=24, dur=8) %&gt;% et(seq(0, 24, length.out=100)) 你可以在下面的图中看到，生物利用度变化对rate影响而不是对输注持续时长影响的对比: library(ggplot2) library(patchwork) p1 &lt;- rxSolve(m1, ev, c(fdepot=1.25)) %&gt;% plot(depot) + xlab(&quot;Time&quot;) + ylim(0,5000) p2 &lt;- rxSolve(m1, ev, c(fdepot=0.25)) %&gt;% plot(depot) + xlab(&quot;Time&quot;)+ ylim(0,5000) ### Use patchwork syntax to combine plots p1 * p2 7.3.2需要估计输注时长或输注速率的输注(零级速率吸收) 您可以对输注持续时长进行建模，这相当于NONMEM的rate=-2。 ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12,until=24, rate=-2) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ── EventTable with 101 records ── #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 100 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 101 × 6 #&gt; time amt rate ii addl evid #&gt; [h] &lt;dbl&gt; &lt;rate/dur&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 NA NA NA NA 0:Observation #&gt; 2 0 10000 -2:dur 12 2 1:Dose (Add) #&gt; 3 0.242 NA NA NA NA 0:Observation #&gt; 4 0.485 NA NA NA NA 0:Observation #&gt; 5 0.727 NA NA NA NA 0:Observation #&gt; 6 0.970 NA NA NA NA 0:Observation #&gt; 7 1.21 NA NA NA NA 0:Observation #&gt; 8 1.45 NA NA NA NA 0:Observation #&gt; 9 1.70 NA NA NA NA 0:Observation #&gt; 10 1.94 NA NA NA NA 0:Observation #&gt; # … with 91 more rows 【译者注：因为上面的代码全是输出的注释，所以虽然是代码，这次也对上述内容进行下翻译，并同时提供翻译和未翻译版，便于读者理解，下文为对上文代码的翻译】 #&gt;── 事件表，其中包含有101条记录 ── #&gt;1个给药记录(参见x$get.dosing();可使用add.dosing #&gt;或et添加) #&gt;100次观测(参见x$get.samping();可使用add.Samples #&gt;或et添加) #&gt;addl列中的多次给药，可使用x$Expand()展开; #&gt;或etExpand(X) #&gt;── 第一部分 关于x： ── #&gt; #A Tibble：101×6 #&gt; 时间 药量 速率 给药间隔 附加给药次数 事件标志 #&gt; [h] &lt;dbl&gt; &lt;rate/dur&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt;1 0 NA NA NA NA 0：观测 #&gt;2 0 10000 -2:dur 12 2 1：给药(及额外附加) #&gt;3 0.242 NA NA NA NA 0：观测 #&gt;4 0.485 NA NA NA NA 0：观测 #&gt;5 0.727 NA NA NA NA 0：观测 #&gt;6 0.970 NA NA NA NA 0：观测 #&gt;7 1.21 NA NA NA NA 0：观测 #&gt;8 1.45 NA NA NA NA 0：观测 #&gt;9 1.70 NA NA NA NA 0：观测 #&gt;10 1.94 NA NA NA NA 0：观测 #…后续还有了91行输出内容 rxSolve(m1, ev, c(durDepot=7)) %&gt;% plot(depot, C2) + xlab(&quot;Time&quot;) 同样，您也可以对吸收速率进行建模。这相当于NONMEM的rate=-1，也是在rxode2的事件表中指定数据项的方式。 ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12,until=24, rate=-1) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ── EventTable with 101 records ── #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 100 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 101 × 6 #&gt; time amt rate ii addl evid #&gt; [h] &lt;dbl&gt; &lt;rate/dur&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 NA NA NA NA 0:Observation #&gt; 2 0 10000 -1:rate 12 2 1:Dose (Add) #&gt; 3 0.242 NA NA NA NA 0:Observation #&gt; 4 0.485 NA NA NA NA 0:Observation #&gt; 5 0.727 NA NA NA NA 0:Observation #&gt; 6 0.970 NA NA NA NA 0:Observation #&gt; 7 1.21 NA NA NA NA 0:Observation #&gt; 8 1.45 NA NA NA NA 0:Observation #&gt; 9 1.70 NA NA NA NA 0:Observation #&gt; 10 1.94 NA NA NA NA 0:Observation #&gt; # … with 91 more rows 【译者注：因为上面的代码全是输出的注释，所以虽然是代码，这次也对上述内容进行下翻译，并同时提供翻译和未翻译版，便于读者理解，下文为对上文代码的翻译】 #&gt;── 事件表，其中包含有101条记录 ── #&gt;1个给药记录(参见x$get.dosing();可使用add.dosing #&gt;或et添加) #&gt;100次观测(参见x$get.samping();可使用add.Samples #&gt;或et添加) #&gt;addl列中的多次给药，可使用x$Expand()展开; #&gt;或etExpand(X) #&gt;── 第一部分 关于x： ── #&gt; #A Tibble：101×6 #&gt; 时间 药量 速率 给药间隔 附加给药次数 事件标志 #&gt; [h] &lt;dbl&gt; &lt;rate/dur&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt;1 0 NA NA NA NA 0：观测 #&gt;2 0 10000 -1:rate 12 2 1：给药(及额外附加) #&gt;3 0.242 NA NA NA NA 0：观测 #&gt;4 0.485 NA NA NA NA 0：观测 #&gt;5 0.727 NA NA NA NA 0：观测 #&gt;6 0.970 NA NA NA NA 0：观测 #&gt;7 1.21 NA NA NA NA 0：观测 #&gt;8 1.45 NA NA NA NA 0：观测 #&gt;9 1.70 NA NA NA NA 0：观测 #&gt;10 1.94 NA NA NA NA 0：观测 #&gt; #…后续还有了91行输出内容 rxSolve(m1, ev, c(rateDepot=10000/3)) %&gt;% plot(depot, C2) + xlab(&quot;Time&quot;) 7.4稳态 以事件表中”给药”药量信息和“给出的给药间隔”信息重复足够多次给药直到稳态，然后基于稳态时的给药进行求解。【译者注：即到达稳态时的时间是事件表中SS=1时的时间，有关SS的进一步的中文解释可以见译者所著的Phoenix的输入选项4 稳态 SS一文】 ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12, ss=1) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ── EventTable with 101 records ── #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 100 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; ── First part of x: ── #&gt; # A tibble: 101 × 5 #&gt; time amt ii evid ss #&gt; [h] &lt;dbl&gt; [h] &lt;evid&gt; &lt;int&gt; #&gt; 1 0 NA NA 0:Observation NA #&gt; 2 0 10000 12 1:Dose (Add) 1 #&gt; 3 0.242 NA NA 0:Observation NA #&gt; 4 0.485 NA NA 0:Observation NA #&gt; 5 0.727 NA NA 0:Observation NA #&gt; 6 0.970 NA NA 0:Observation NA #&gt; 7 1.21 NA NA 0:Observation NA #&gt; 8 1.45 NA NA 0:Observation NA #&gt; 9 1.70 NA NA 0:Observation NA #&gt; 10 1.94 NA NA 0:Observation NA #&gt; # … with 91 more rows 【译者注：因为上面的代码全是输出的注释，所以虽然是代码，这次也对上述内容进行下翻译，并同时提供翻译和未翻译版，便于读者理解，下文为对上文代码的翻译】 #&gt;── 事件表，其中包含有101条记录 ── #&gt;1个给药记录(参见x$get.dosing();可使用add.dosing #&gt;或et添加) #&gt;100次观测(参见x$get.samping();可使用add.Samples #&gt;或et添加) #&gt;addl列中的多次给药，可使用x$Expand()展开; #&gt;或etExpand(X) #&gt;── 第一部分 关于x： ── #&gt; #A Tibble：101×6 #&gt; 时间 药量 给药间隔 附加给药次数 事件标志 稳态 #&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; &lt;int&gt; #&gt; 1 0 NA NA NA 0：观测 NA #&gt; 2 0 10000 12 2 1：给药(及额外附加) 1 #&gt; 3 0.242 NA NA NA 0：观测 NA #&gt; 4 0.485 NA NA NA 0：观测 NA #&gt; 5 0.727 NA NA NA 0：观测 NA #&gt; 6 0.970 NA NA NA 0：观测 NA #&gt; 7 1.21 NA NA NA 0：观测 NA #&gt; 8 1.45 NA NA NA 0：观测 NA #&gt; 9 1.70 NA NA NA 0：观测 NA #&gt;10 1.94 NA NA NA 0：观测 NA #…后续还有了91行输出内容 rxSolve(m1, ev) %&gt;% plot(C2) 7.4.1复杂加药的稳定状态 通过使用ss=2标志，您可以使用类似”早上100 mg vs晚上150 mg“这样的不太规整的给药方案【译者注：吐槽，原文使用nonstandard dosing(非标准给药)容此给药方案，但这种给药方案在临床挺”标准”的，仅仅是有些嵌套而已，这种嵌套给基于NCA的PK参数带来了些麻烦，估计作者是因此将此种方案定义为不标准;所以我基于我的上述理由将此翻译为不太规整，以此来表达原文作者想表达含义】基于线性动力学中的超定位原理(super-positioning)【译者注：没见过其他人在药动学中提到此词，我猜作者可能是想说线性药动学的线性叠加原理】到达稳态。这是通过: 保存所有状态值 重置所有状态，求解系统至稳态 将所有先前的状态值加回来 ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=24, ss=1) %&gt;% et(time=12, amt=15000, ii=24, ss=2) %&gt;% et(time=24, amt=10000, ii=24, addl=3) %&gt;% et(time=36, amt=15000, ii=24, addl=3) %&gt;% et(seq(0, 64, length.out=500)) library(ggplot2) rxSolve(m1, ev,maxsteps=10000) %&gt;% plot(C2) + annotate(&quot;rect&quot;, xmin=0, xmax=24, ymin=-Inf, ymax=Inf, alpha=0.2) + annotate(&quot;text&quot;, x=12.5, y=7, label=&quot;Initial Steady State Period&quot;) + annotate(&quot;text&quot;, x=44, y=7, label=&quot;Steady State AM/PM dosing&quot;) 你可以看到，它需要一个完整的给药周期才能达到真正的复杂给药方案的稳态【译者注：此时到达稳态时的时间还是事件表中SS=1时的时间，Phoenix实现此类给药方案到达稳态的方式与此有些略微差异，是将SS=1和SS=2的信息卸载一行中的不同列并且SS=1，有关SS的进一步的中文解释可以见译者所著的Phoenix的输入选项4 稳态 SS一文】。 7.4.2输注或零阶吸收过程的稳态 rxode2支持的最后一种稳态是恒定输注速率数值直到输注到达稳态。这可以用与NONMEM相同的方式指定，即: 没有给药间间隔时间ii=0 稳态标识ss=1 输入已知的输注速率(此时事件表汇中rate&gt;0)，或估计输注速率(此时rate=-1)。 药量为零amt=0 一旦达到稳态恒定输注，使用此记录时将关闭输注，就像NONMEM一样。 请注意，我们为模型指定输注持续时长的rate=-2没有多大意义，因为我们是在求解输注直到稳定状态。输注持续时长由稳态解指定。 还需要注意的是，这种输注至稳态的生物利用度变化也没有意义，因为它们既没有改变稳态输注的速率，也没有改变输注的持续时长。因此，这种给药事件的生物利用度参数化被忽略。 下面是一个例子: ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=0, ss=1,rate=10000/8) p1 &lt;- rxSolve(m1, ev) %&gt;% plot(C2, eff) ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=200000, rate=10000/8) %&gt;% et(0, 250, length.out=1000) p2 &lt;- rxSolve(m1, ev) %&gt;% plot(C2, eff) library(patchwork) p1 / p2 这不仅可以用于PK，也可以用于疾病过程的稳态。 7.5重置事件 重置事件通过evid=3或evid= reset实现，对于同时reset和dose, 由evid=4实现。 ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12, addl=3) %&gt;% et(time=6, evid=reset) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ── EventTable with 102 records ── #&gt; 2 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 100 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 102 × 5 #&gt; time amt ii addl evid #&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 NA NA NA 0:Observation #&gt; 2 0 10000 12 3 1:Dose (Add) #&gt; 3 0.242 NA NA NA 0:Observation #&gt; 4 0.485 NA NA NA 0:Observation #&gt; 5 0.727 NA NA NA 0:Observation #&gt; 6 0.970 NA NA NA 0:Observation #&gt; 7 1.21 NA NA NA 0:Observation #&gt; 8 1.45 NA NA NA 0:Observation #&gt; 9 1.70 NA NA NA 0:Observation #&gt; 10 1.94 NA NA NA 0:Observation #&gt; # … with 92 more rows 【译者注：因为上面的代码全是输出的注释，所以虽然是代码，这次也对上述内容进行下翻译，并同时提供翻译和未翻译版，便于读者理解，下文为对上文代码的翻译】 #&gt;── 事件表，其中包含有102条记录 ── #&gt;2个给药记录(参见x$get.dosing();可使用add.dosing #&gt;或et添加) #&gt;100次观测(参见x$get.samping();可使用add.Samples #&gt;或et添加) #&gt;addl列中的多次给药，可使用x$Expand()展开; #&gt;或etExpand(X) #&gt;── 第一部分 关于x： ── #&gt; #A Tibble：102×5 #&gt; 时间 药量 给药间隔 附加给药次数 事件标志 #&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 NA NA NA 0：观测 #&gt; 2 0 10000 12 3 1：给药(及额外附加) #&gt; 3 0.242 NA NA NA 0：观测 #&gt; 4 0.485 NA NA NA 0：观测 #&gt; 5 0.727 NA NA NA 0：观测 #&gt; 6 0.970 NA NA NA 0：观测 #&gt; 7 1.21 NA NA NA 0：观测 #&gt; 8 1.45 NA NA NA 0：观测 #&gt; 9 1.70 NA NA NA 0：观测 #&gt;10 1.94 NA NA NA 0：观测 #…后续还有了92行输出内容 求解器显示了当系统在给药后6小时重置时，系统中发生的情况。 rxSolve(m1, ev) %&gt;% plot(depot,C2, eff) 您可以看到所有房室都被重置为初始值。在下一次给药时开始给药的循环周期。 ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12, addl=3) %&gt;% et(time=6, amt=10000, evid=4) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ── EventTable with 102 records ── #&gt; 2 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 100 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 102 × 5 #&gt; time amt ii addl evid #&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 NA NA NA 0:Observation #&gt; 2 0 10000 12 3 1:Dose (Add) #&gt; 3 0.242 NA NA NA 0:Observation #&gt; 4 0.485 NA NA NA 0:Observation #&gt; 5 0.727 NA NA NA 0:Observation #&gt; 6 0.970 NA NA NA 0:Observation #&gt; 7 1.21 NA NA NA 0:Observation #&gt; 8 1.45 NA NA NA 0:Observation #&gt; 9 1.70 NA NA NA 0:Observation #&gt; 10 1.94 NA NA NA 0:Observation #&gt; # … with 92 more rows 【译者注：因为上面的代码全是输出的注释，所以虽然是代码，这次也对上述内容进行下翻译，并同时提供翻译和未翻译版，便于读者理解，下文为对上文代码的翻译】 #&gt;── 事件表，其中包含有102条记录 ── #&gt;2个给药记录(参见x$get.dosing();可使用add.dosing #&gt;或et添加) #&gt;100次观测(参见x$get.samping();可使用add.Samples #&gt;或et添加) #&gt;addl列中的多次给药，可使用x$Expand()展开; #&gt;或etExpand(X) #&gt;── 第一部分 关于x： ── #&gt; #A Tibble：102×5 #&gt; 时间 药量 给药间隔 附加给药次数 事件标志 #&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 NA NA NA 0：观测 #&gt; 2 0 10000 12 3 1：给药(及额外附加) #&gt; 3 0.242 NA NA NA 0：观测 #&gt; 4 0.485 NA NA NA 0：观测 #&gt; 5 0.727 NA NA NA 0：观测 #&gt; 6 0.970 NA NA NA 0：观测 #&gt; 7 1.21 NA NA NA 0：观测 #&gt; 8 1.45 NA NA NA 0：观测 #&gt; 9 1.70 NA NA NA 0：观测 #&gt;10 1.94 NA NA NA 0：观测 #…后续还有了92行输出内容 在这种情况下，整个系统被重置并在重置时发生给药。 rxSolve(m1, ev) %&gt;% plot(depot,C2, eff) 7.6关闭房室 您也可以关闭一个房室，这类似于重置事件。 ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12, addl=3) %&gt;% et(time=6, cmt=&quot;-depot&quot;, evid=2) %&gt;% et(seq(0, 24, length.out=100)) ev #&gt; ── EventTable with 102 records ── #&gt; 2 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 100 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 102 × 6 #&gt; time cmt amt ii addl evid #&gt; [h] &lt;chr&gt; &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 (obs) NA NA NA 0:Observation #&gt; 2 0 (default) 10000 12 3 1:Dose (Add) #&gt; 3 0.242 (obs) NA NA NA 0:Observation #&gt; 4 0.485 (obs) NA NA NA 0:Observation #&gt; 5 0.727 (obs) NA NA NA 0:Observation #&gt; 6 0.970 (obs) NA NA NA 0:Observation #&gt; 7 1.21 (obs) NA NA NA 0:Observation #&gt; 8 1.45 (obs) NA NA NA 0:Observation #&gt; 9 1.70 (obs) NA NA NA 0:Observation #&gt; 10 1.94 (obs) NA NA NA 0:Observation #&gt; # … with 92 more rows #&gt;── 事件表，其中包含有102条记录 ── #&gt;2个给药记录(参见x$get.dosing();可使用add.dosing #&gt;或et添加) #&gt;100次观测(参见x$get.samping();可使用add.Samples #&gt;或et添加) #&gt;addl列中的多次给药，可使用x$Expand()展开; #&gt;或etExpand(X) #&gt;── 第一部分 关于x： ── #&gt; #A Tibble：102×6 #&gt; 时间 cmt 药量 给药间隔 附加给药次数 事件标志 #&gt; [h] &lt;chr&gt; &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 (obs) NA NA NA 0：观测 #&gt; 2 0 (default) 10000 12 3 1：给药(及额外附加) #&gt; 3 0.242(obs) NA NA NA 0：观测 #&gt; 4 0.485(obs) NA NA NA 0：观测 #&gt; 5 0.727(obs) NA NA NA 0：观测 #&gt; 6 0.970(obs) NA NA NA 0：观测 #&gt; 7 1.21 (obs) NA NA NA 0：观测 #&gt; 8 1.45 (obs) NA NA NA 0：观测 #&gt; 9 1.70 (obs) NA NA NA 0：观测 #&gt;10 1.94 (obs) NA NA NA 0：观测 #…后续还有了92行输出内容 求解器显示了这在系统中的作用: rxSolve(m1, ev) %&gt;% plot(depot,C2, eff) 在这种情况下，depot房室关闭，depot房室中的浓度被设置为初始值，但其他房室浓度/水平不重置。当depot房室发生另一次给药时，depot房室重新打开。 请注意，对房室的给药只会对被给药的房室起作用。因此，如果你关闭eff房室，即使另一个房室depot房室发生给药后，eff房室会仍然继续关闭。 ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12, addl=3) %&gt;% et(time=6, cmt=&quot;-eff&quot;, evid=2) %&gt;% et(seq(0, 24, length.out=100)) rxSolve(m1, ev) %&gt;% plot(depot,C2, eff) 要重新打开房室，需要对此房室进行一次药量为零的给药或与为此房室添加一个evid=2的记录。 ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, ii=12, addl=3) %&gt;% et(time=6, cmt=&quot;-eff&quot;, evid=2) %&gt;% et(time=12,cmt=&quot;eff&quot;,evid=2) %&gt;% et(seq(0, 24, length.out=100)) rxSolve(m1, ev) %&gt;% plot(depot,C2, eff) 7.7经典的rxode2事件 【译者注：由于rxode2还有前一代版本rxode，所以为了兼容性也支持前一代版本中的evid的编码方式，对于不了解前代前一代版本rxode读者，无需学习与了解此章节，跳过整个7.7章节即可。】 最初RxODE支持复合事件IDs;rxode2仍然支持这些参数，但使用常规的NONMEM数据集标准通常更有用，部分建模工具也使用该标准，如在rxode2类型文章中有描述到的NONMEM、Monolix和nlmixr。 通常，RxODE支持在下表中描述的单个事件idevid中进行事件编码。 100 + cmt Infusion/Event Flag 输注标志或事件标志 100 + cmt 0 = bolus dose 0 =注入式给药 1 = infusion (rate) 1 =输注(速率) 2 = infusion (dur) 2 =输注(时长) 6 = turn off modeled duration 6 =关闭输注时长 7 = turn off modeled rate 7 =关闭输注速率 8 = turn on modeled duration 8 =打开输注时长 9 = turn on modeled rate 9 =打开输注速率 4 = replace event 4 =替换事件 5 = multiply event 5 =倍数事件 &lt; 99 cmt SS flag &amp; Turning of Compartment SS标志和房室关闭 &lt; 99 cmt 1 = dose 1 =给药 10 = Steady state 1 (equivalent to SS=1) 10 =稳态1(相当于SS=1) 20 = Steady state 2 (equivalent to SS=2) 20 =稳态2(相当于SS=2) 30 = Turn off a compartment (equivalent to -CMT w/EVID=2) 30 =关闭一个房室(相当于-CMT w/EVID=2) 经典的EVID将上表中的数字连接起来，因此向1号房室的输注将是10101，向199号室的输注将是119901。 支持EVID= 0(观测)、EVID=2(其他类型事件)和EVID=3。在内部，EVID=9是一个非观测事件，确保系统初始化为零;EVID=9不能手动设置。EVID 10-99表示参数化模型的时间干预，类似于NONMEM的MTIME(model-event-times)。这与药量(amt)和时间列一起指定ODE系统中的事件。 对于指定的EVIDs &gt; 100的输注，amt列表示速率值。 对于输注标志1和2 +amt打开输注到特定的房室-amt关闭输注到特定的房室。要指定给药/持续时长，请将给药记录放在持续时长开始或停止的时间。 对于使用输注速率/持续时长输注参数化的输注的标志，在输注喀什市标志之后必须有一个停止输注的记录。 这些数字连接在一起形成一个完整的RxODE事件ID，如下面的例子所示: 7.7.1使用经典RxODE的EVID设置注入给药示例 在第0时刻给#1号房室注入100剂量 time evid amt 0 101 100 0.5 0 0 1 0 0 在第0时刻给#99号房室注入100剂量 时间 evid amt 0 9901 100 0.5 0 0 1 0 0 在第0时刻给$199号房室注入100剂量 时间 evid amt 0 109901 100 0.5 0 0 1 0 0 7.7.2使用经典RxODE的EVID设置输注事件示例 对#1号房室以速率50输注1.5小时(使用生物利用度参数化时，生物利用度的变化会改变输注时长) time evid amt 0 10101 50 0.5 0 0 1 0 0 1.5 10101 -50 对#1号房室以速率50输注1.5小时(使用生物利用度参数化时，生物利用度的变化改变输注速率) time evid amt 0 20101 50 0.5 0 0 1 0 0 1.5 20101 -50 模型以输注速率参数化并且药量为50 time evid amt 0 90101 50 0 70101 50 0.5 0 0 1 0 0 模型以输注时长参数化并且药量为50 time evid amt 0 80101 50 0 60101 50 0.5 0 0 1 0 0 7.7.3使用经典RxODE的EVID设置稳态的例子 给药至#1号房室至达稳态 time evid amt 0 110 50 am50 pm 100给药至#1号房室至达稳 time evid amt 0 110 50 12 120 100 7.7.4使用经典RxODE的EVID关闭房室 在时间为12时关闭#1号房室 time evid amt 0 110 50 12 130 NA 在rxode2中的事件标识码被编码为单个事件编号evid。对于100以下的房室，编码如下: 对于观察事件的事件是0。 对于特定的房室，注入给药定义为: 100*(房室号)+ 1 捕获amt后给药 对于静脉注射【译者注：原文此处似乎笔误，此处应为静脉输注】给药，事件定义为: 10000 + 100*(房室号)+ 1 输注速率记录在amt列 通过在输注停止时用相同的EVID减法amt来关闭输注。 对于大于或等于100的房室，100位及以上的数字被转移到第100,000位数字。对于第99个房室的给药，注入房室的给药evid是9901，输注方式的给药evid是19901。第199房室的剂量是109901。第199室的输液剂量记录为119901。 7.8rxode2 &amp; nlmixr的数据集 输入nlmixr的数据与rxode2的数据输入类型相同，它与NONMEM的数据相似(大多数NONMEM就绪的数据集可以直接在nlmixr中使用)。 7.9按使用类型描述的列 7.9.1个体标识符列 受试者个体识别列将受试者个体分开以识别随机效应。 ID:个体标识符，可以是整数、字符或因子。 7.9.2观测列 观察列用于指示因变量以及如何使用或测量它。 DV:包含测量值的数字列 CENS表示删失的数字列，如低于测定的定量下限。 LIMIT一个数值列，用于帮助指示删失的类型，如低于测定的定量下限。 MDV:DV值缺失的指示符 CMT:房室的名称或编号 DVID:因变量标识符 EVID事件标识符 7.9.3给药列 AMT:给药量的具体数值 CMT:房室的名称或编号 EVID:事件标识符 ADDL:额外附加的给药的次数 RATE或DUR剂量:给药的速率或持续时长 7.9.4协变量列 7.10特定数据集列的详细信息 下面的详细信息按列名的字母顺序排序。要按用途分组，请参阅上面的文档。 7.10.1 AMT列 AMT列定义了给药的药量。 对于观测行，它应该是0或NA。 对于给药行，它是给予CMT的给药量。如果给药为零阶速率(如恒定速率输注)，则可以使用RATE或DUR列设置输注。 7.10.2 CENS/LIMIT列 CENS列是指示是否发生删失的指示列。对于药代动力学建模，通常在样品低于定量下限时进行删失。在rxode2内部保存这些值，以便nlmixr可以在似然计算中使用它们。 CENS = 0表示测量DV值时未删失。 CENS = 1表示一个值是左删失(或低于定量下限)，DV中的值是删失/定量极限。 CENS = -1表示一个值是右删失(或超过定量上限)，DV中的值为删失/定量极限。 LIMIT是关于nlmixr如何处理删失的附加信息，也存储在rxode2的数据结构中。当一个值处于删失状态时，比如低于定量下限1，您可能还会认为该值高于某个阈值，比如零。在这种情况下，0表示截尾值在0到1之间。 简而言之: CENS = 0，LIMIT被忽略，因为观测值未删失 CENS = 1，个体预测值在(LIMIT, DV)范围内 CENS = -1，个体预测值在(DV, LIMIT)范围内 7.10.3 CMT列 CMT列表示事件发生的房室。当作为字符串或因子(首选方法)给出时，它将根据模型中的名称进行匹配。当以整数形式给出时，它与模型中出现的房室顺序相匹配。 7.10.4 DUR列 DUR列定义了一次输注的持续时长。它用于设置零级输注速率的持续时间。 7.10.5 DV列 DV列表示当前房室(见CMT)中观测到的当前测量值，带有当前测量标识符(见DVID)，该列数值可能缺失(见MDV)或删失(见CENS)。 7.10.6 DVID列 待办事项【译者注：这是作者下写给自己的话，意思是这里他还没有撰写或者在代码中实现，有待于未来完成此事】 7.10.7 EVID列 EVID列是一行数据的事件标识符。 对于观测记录行，它将是0。对于常规给药记录，它将是1。在rxode2事件类型和经典rxode事件插图中详细介绍了更多EVID值。 7.10.8 ID列 ID列是个体标识符。这一栏用于将个体(通常是单个人或动物)与另一个个体分开。 在模型中，ID列用于分离个体。数值积分器会为每个新个体重新初始化，并为所有随机效应选择新值。 7.10.9 RaTE列 待办事项【译者注：这是作者下写给自己的话，意思是这里他还没有撰写或者在代码中实现，有待于未来完成此事】 "],["第八章轻松创建rxode2事件.html", "第八章轻松创建rxode2事件 8.1向事件表添加给药 8.2 将采样添加到事件表 8.3将事件表展开为多个个体的事件表。 8.4在采样窗口内添加给药和采样 8.5组合事件表 8.6按序列组合事件表 8.7通过对事件表重复组合事件表 8.8 使用rbind组合事件表 8.9展开事件 8.10RStudio笔记本中的事件表", " 第八章轻松创建rxode2事件 rxode2中的事件表是一个专门的数据框，充当rxode2的所有事件和观测时间的容器。 要创建rxode2事件表，可以使用代码eventTable()， et()，甚至可以自己直接使用数据框创建事件表，自己直接使用数据框创建事件表时应确保其中包含正确事件信息。这与rxode2支持的事件类型密切相关。 library(rxode2) library(units) #&gt; udunits database from /usr/share/xml/udunits/udunits2.xml (ev &lt;- eventTable()) #&gt; ── EventTable with 0 records ── #&gt; 0 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 0 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) 或者 (ev &lt;- et()) #&gt; ── EventTable with 0 records ── #&gt; 0 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 0 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) 使用此事件表，您可以通过管道或直接访问此事件表向其中添加采样/观测或给药记录。 下表列出了用于创建给药记录的两个主要函数 add.dosing()函数 et()函数 描述 dose amt 给药的药量 nbr.doses addl 额外附加的给药次数 dosing.interval ii 给药间隔 dosing.to cmt 给药房室 rate rate 输注速率 start.time time 给药开始时间 dur 输注持续是擦汗给你 采样时间可以通过add.sampling(采样时间)或 et(采样时间)添加。给药时间窗和采样时间窗也是支持。 对于这些模型，我们可以使用rxode2教程中分享的模型来说明： ## Model from rxode2 tutorial m1 &lt;-rxode2({ KA=2.94E-01; CL=1.86E+01; V2=4.02E+01; Q=1.05E+01; V3=2.97E+02; Kin=1; Kout=1; EC50=200; ## Added modeled bioavaiblity, duration and rate fdepot = 1; durDepot = 8; rateDepot = 1250; C2 = centr/V2; C3 = peri/V3; d/dt(depot) =-KA*depot; f(depot) = fdepot dur(depot) = durDepot rate(depot) = rateDepot d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; eff(0) = 1 }) 8.1向事件表添加给药 事件表一旦创建，您就可以通过add.dosing()和et()函数将给药添加到事件表 。 使用 add.dosing()函数时您需要: 所需的参数 含义用途 dose 给药的药量 nbr.doses 给药次数;至少是1. dosing.interval 给药间隔;默认为24. dosing.to 给药的房室. rate 输注速率 start.time 给药开始的时间 ev &lt;- eventTable(amount.units=&quot;mg&quot;, time.units=&quot;hr&quot;) ## The methods ar attached to the event table, so you can use ## them directly ev$add.dosing(dose=10000, nbr.doses = 3)# loading doses ## Starts at time 0; Default dosing interval is 24 ## You can also pipe the event tables to these methods. ev &lt;- ev %&gt;% add.dosing(dose=5000, nbr.doses=14, dosing.interval=12)# maintenance ev #&gt; ── EventTable with 2 records ── #&gt; 2 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 0 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 2 × 5 #&gt; time amt ii addl evid #&gt; [h] [mg] [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 10000 24 2 1:Dose (Add) #&gt; 2 0 5000 12 13 1:Dose (Add) 请注意，单位已在表中指定。指定后，单位将使用unitsR添加包追踪单位，并在需要时进行转换。此外，ggforce使用它们来标记 ggplot坐标轴。对设置和删除rxode2事件表的单位时可以使用set_units和drop_units函数。【译者注：我在自己本地环境，开始时无法实现原作者描述的对单位的修改，在重新R后，上述对单位的修改可以实现了，所以在新手初次尝试示例前最后重启一次R，以确保案例可重现】 在此示例中，您可以看到时间坐标轴标记出了单位： rxSolve(m1, ev) %&gt;% plot(C2) 如果您更熟悉NONMEM/rxode2事件记录，您还可以直接使用带有dose元素的et指定给药: ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, until = set_units(3, days), ii=12) # loading doses ev #&gt; ── EventTable with 1 records ── #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 0 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 1 × 5 #&gt; time amt ii addl evid #&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 10000 12 6 1:Dose (Add) 其中给出： rxSolve(m1, ev) %&gt;% plot(C2) 这显示出了创建事件表是多么的容易。 8.2 将采样添加到事件表 上面的示例如果您注意看会发现，rxode2生成了一些默认的采样时间，这因为没有任何采样时间。如果希望对采样时间进行更多控制，则应通过add.sampling或et将采样添加到rxode2的事件表中 ev &lt;- eventTable(amount.units=&quot;mg&quot;, time.units=&quot;hr&quot;) ## The methods ar attached to the event table, so you can use them ## directly ev$add.dosing(dose=10000, nbr.doses = 3)# loading doses ev$add.sampling(seq(0,24,by=4)) ev #&gt; ── EventTable with 8 records ── #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 7 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 8 × 5 #&gt; time amt ii addl evid #&gt; [h] [mg] [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 NA NA NA 0:Observation #&gt; 2 0 10000 24 2 1:Dose (Add) #&gt; 3 4 NA NA NA 0:Observation #&gt; 4 8 NA NA NA 0:Observation #&gt; 5 12 NA NA NA 0:Observation #&gt; 6 16 NA NA NA 0:Observation #&gt; 7 20 NA NA NA 0:Observation #&gt; 8 24 NA NA NA 0:Observation 上述代码将给出： solve(m1, ev) %&gt;% plot(C2) 或者，如果您也可以使用et，您可以简单地以与add.sampling类似的方式添加它们： ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, until = set_units(3, days), ii=12) %&gt;% # loading doses et(seq(0,24,by=4)) ev #&gt; ── EventTable with 8 records ── #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 7 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 8 × 5 #&gt; time amt ii addl evid #&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 0 NA NA NA 0:Observation #&gt; 2 0 10000 12 6 1:Dose (Add) #&gt; 3 4 NA NA NA 0:Observation #&gt; 4 8 NA NA NA 0:Observation #&gt; 5 12 NA NA NA 0:Observation #&gt; 6 16 NA NA NA 0:Observation #&gt; 7 20 NA NA NA 0:Observation #&gt; 8 24 NA NA NA 0:Observation rxode2求解后上述代码将给出以下： solve(m1, ev) %&gt;% plot(C2) 请注意这些图的锯齿状性质，这是因为仅有几个采样时间。 8.3将事件表展开为多个个体的事件表。 展开事件表唯一需要的是要展开的ID列表; ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000, until = set_units(3, days), ii=12) %&gt;% # loading doses et(seq(0,48,length.out=200)) %&gt;% et(id=1:4) ev #&gt; ── EventTable with 804 records ── #&gt; 4 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 800 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 804 × 6 #&gt; id time amt ii addl evid #&gt; &lt;int&gt; [h] &lt;dbl&gt; [h] &lt;int&gt; &lt;evid&gt; #&gt; 1 1 0 NA NA NA 0:Observation #&gt; 2 1 0 10000 12 6 1:Dose (Add) #&gt; 3 1 0.241 NA NA NA 0:Observation #&gt; 4 1 0.482 NA NA NA 0:Observation #&gt; 5 1 0.724 NA NA NA 0:Observation #&gt; 6 1 0.965 NA NA NA 0:Observation #&gt; 7 1 1.21 NA NA NA 0:Observation #&gt; 8 1 1.45 NA NA NA 0:Observation #&gt; 9 1 1.69 NA NA NA 0:Observation #&gt; 10 1 1.93 NA NA NA 0:Observation #&gt; # … with 794 more rows 您可以在以下模拟中看到有4个个体被求解： set.seed(42) rxSetSeed(42) solve(m1, ev, params=data.frame(KA=0.294*exp(rnorm(4)), 18.6*exp(rnorm(4)))) %&gt;% plot(C2) 8.4在采样窗口内添加给药和采样 除了添加固定给药和固定采样时间之外，您还可以设置采样和给药的时间窗口。对于给药时间窗，您可以在time参数(时间参数)中指定，此时将time指定为一个list列表，该list中包含有一个有序数字向量，向量中含有两个元素，分别表示给药时间的下限和给药时间窗的上限【译者注：比如time=list(c(0,6))，当于计划给药时间为t时，此时的时间窗为[t+0,t+6]】。 对于给药时间窗的示例，您从给药时间的给药时间窗为6小时的示例开始，示例如下： set.seed(42) rxSetSeed(42) ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(time=list(c(0,6)), amt=10000, until = set_units(2, days), ii=12) %&gt;% # loading doses et(id=1:4) ev #&gt; ── EventTable with 16 records ── #&gt; 16 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 0 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; ── First part of x: ── #&gt; # A tibble: 16 × 6 #&gt; id low time high amt evid #&gt; &lt;int&gt; [h] [h] [h] &lt;dbl&gt; &lt;evid&gt; #&gt; 1 1 0 5.49 6 10000 1:Dose (Add) #&gt; 2 1 12 17.0 18 10000 1:Dose (Add) #&gt; 3 1 24 25.7 30 10000 1:Dose (Add) #&gt; 4 1 36 41.6 42 10000 1:Dose (Add) #&gt; 5 2 0 4.31 6 10000 1:Dose (Add) #&gt; 6 2 12 14.7 18 10000 1:Dose (Add) #&gt; 7 2 24 28.2 30 10000 1:Dose (Add) #&gt; 8 2 36 39.9 42 10000 1:Dose (Add) #&gt; 9 3 0 0.808 6 10000 1:Dose (Add) #&gt; 10 3 12 16.4 18 10000 1:Dose (Add) #&gt; 11 3 24 27.1 30 10000 1:Dose (Add) #&gt; 12 3 36 39.9 42 10000 1:Dose (Add) #&gt; 13 4 0 4.98 6 10000 1:Dose (Add) #&gt; 14 4 12 13.7 18 10000 1:Dose (Add) #&gt; 15 4 24 29.6 30 10000 1:Dose (Add) #&gt; 16 4 36 41.5 42 10000 1:Dose (Add) 在下面的模拟中，您可以清楚地看到不同的剂量时间窗： ev &lt;- ev %&gt;% et(seq(0,48,length.out=200)) solve(m1, ev, params=data.frame(KA=0.294*exp(rnorm(4)), 18.6*exp(rnorm(4)))) %&gt;% plot(C2) 当然，在现实中，给药时间窗可能只有2小时： set.seed(42) rxSetSeed(42) ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(time=list(c(0,2)), amt=10000, until = set_units(2, days), ii=12) %&gt;% # loading doses et(id=1:4) %&gt;% et(seq(0,48,length.out=200)) solve(m1, ev, params=data.frame(KA=0.294*exp(rnorm(4)), 18.6*exp(rnorm(4)))) %&gt;% plot(C2) 同样的事情可以用于指定采样的采样时间。要以采样时间窗的形式指定采样时间，您可以创建采样时间列表。其中的每个采样时间将是一个list列表，list中是一个含有两个元素的有序的数字向量。 rxSetSeed(42) set.seed(42) ev &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(time=list(c(0,2)), amt=10000, until = set_units(2, days), ii=12) %&gt;% # loading doses et(id=1:4) ## Create 20 samples in the first 24 hours and 20 samples in the ## second 24 hours ## 在第一个24小时内，创建20个采样;在第二个24小时内，创建20个采 ## 【译者注：即在第一个24小时内，随机20次采样，因为前个采样的时间窗都是[0,24]】 samples &lt;- c(lapply(1:20, function(...){c(0,24)}), lapply(1:20, function(...){c(20,48)})) ## Add the random collection to the event table ## 将随机采样添加到事件表中 ev &lt;- ev %&gt;% et(samples) library(ggplot2) solve(m1, ev, params=data.frame(KA=0.294*exp(rnorm(4)), 18.6*exp(rnorm(4)))) %&gt;% plot(C2) + geom_point() 这显示了rxode2事件表允许的给药和采样的灵活性。 8.5组合事件表 由于您可以创建给药记录和采样记录，因此您可以您创建任何您希望的复杂给药方案。此外，rxode2允许您通过c、seq、rep和rbind函数组合事件表。 8.6按序列组合事件表 组合事件表的一种方法是通过c、seq或 etSeq按序列进行组合。这需要两个给药组，并在它们之间加上至少一个给药间隔:： ## bid for 5 days bid &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000,ii=12,until=set_units(5, &quot;days&quot;)) ## qd for 5 days qd &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=20000,ii=24,until=set_units(5, &quot;days&quot;)) ## bid for 5 days followed by qd for 5 days et &lt;- seq(bid,qd) %&gt;% et(seq(0,11*24,length.out=100)); rxSolve(m1, et) %&gt;% plot(C2) 在对事件按序列组合时，您还可以在此序列插入一段时间将前后两个分隔开;例如，如果你想以一周为间隔，你可以用下面的事件表序列轻松地做到这一点: ## bid for 5 days followed by qd for 5 days et &lt;- seq(bid,set_units(1, &quot;week&quot;), qd) %&gt;% et(seq(0,18*24,length.out=100)); rxSolve(m1, et) %&gt;% plot(C2) 请注意，在本例中，bid和qd事件表之间的时间正好是一周，而不是一周加24小时，因为存在给药间隔时间。如果你想要这种行为，你可以在按序列组合时使用wait=\"+ii\"。【译者注：不要怀疑你没有看懂，因为我在本地测试，发现添加wait=“+ii”后毫无变化，无论在两个事件表格间插入1还是插入13，都无变化，怀疑是一个bug;因为是否使用wait=“+ii”，其行为都与默认的samrt方式一样】 ## bid for 5 days followed by qd for 5 days et &lt;- seq(bid,set_units(1, &quot;week&quot;), qd,wait=&quot;+ii&quot;) %&gt;% et(seq(0,18*24,length.out=100)); rxSolve(m1, et) %&gt;% plot(C2) 还要注意的是，rxode2假定您希望按照给药来分隔事件表，并在组合事件表时清除所有采样记录。如果不是这样，您还可以使用选项samples=\"use\" 8.7通过对事件表重复组合事件表 您可以使用etRep或rep重复事件表。 例如，可以为期2周的QD治疗和1周的休息治疗为一轮，一共重复4论，这样的治疗方案可以简单地指定出来： qd &lt;-et(timeUnits = &quot;hr&quot;) %&gt;% et(amt=10000, ii=24, until=set_units(2, &quot;weeks&quot;), cmt=&quot;depot&quot;) et &lt;- rep(qd, times=4, wait=set_units(1,&quot;weeks&quot;)) %&gt;% add.sampling(set_units(seq(0, 12.5,by=0.005),weeks)) rxSolve(m1, et) %&gt;% plot(C2) 这是使用事件表按序列组合的一种简化方法。 因此，许多相同的选项仍然适用;也就是说，除非使用samples=\"use\"，否则samples将被清除，事件表之间的时间至少是给药间隔。你可以通过wait选项来调整时间 。 8.8 使用rbind组合事件表 您可以将事件表与rbind结合使用。这在组合事件表时不考虑事件的时间，而是保持它们相同的时间。如果你用等待时间间隔事件表，则它再不考虑给药间隔。 使用前面的seq，您可以清楚地看到他们两个之间的差异。以下是采用按序列组合时间表: ## bid for 5 days bid &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=10000,ii=12,until=set_units(5, &quot;days&quot;)) ## qd for 5 days qd &lt;- et(timeUnits=&quot;hr&quot;) %&gt;% et(amt=20000,ii=24,until=set_units(5, &quot;days&quot;)) et &lt;- seq(bid,qd) %&gt;% et(seq(0,18*24,length.out=500)); rxSolve(m1, et) %&gt;% plot(C2) 但是如果你把它们通过rbind组合 ## bid for 5 days et &lt;- rbind(bid,qd) %&gt;% et(seq(0,18*24,length.out=500)); rxSolve(m1, et) %&gt;% plot(C2) 仍然适用等待期（但不考虑剂量间隔） et &lt;- rbind(bid,wait=set_units(10,days),qd) %&gt;% et(seq(0,18*24,length.out=500)); rxSolve(m1, et) %&gt;% plot(C2) 您还可以将这些表绑定在一起，并使事件表中的每个ID唯一;这可以很好地将具有不同预期剂量和采样时间的队列组合起来。这需要id=\"unique\"选项;使用第一个例子可以显示出在这种情况下这是如何不同的: ## bid for 5 days et &lt;- etRbind(bid,qd, id=&quot;unique&quot;) %&gt;% et(seq(0,150,length.out=500)); library(ggplot2) rxSolve(m1, et) %&gt;% plot(C2) + facet_wrap( ~ id) 8.9展开事件 可以将事件表展开，使其将由addl折叠为一行的记录展开为多行记录，如下例所示： ev &lt;- et() %&gt;% et(dose=50, ii=8, until=48) ev #&gt; ── EventTable with 1 records ── #&gt; 1 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 0 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with x$expand(); #&gt; or etExpand(x) #&gt; ── First part of x: ── #&gt; # A tibble: 1 × 5 #&gt; time amt ii addl evid #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;evid&gt; #&gt; 1 0 50 8 6 1:Dose (Add) 您可以通过$expand()或etExpand(ev)来展开事件，使其不再包含addl项: 第一种方式，etExpand(ev)在不修改原始数据帧的情况下展开事件表: etExpand(ev) #&gt; ── EventTable with 7 records ── #&gt; 7 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 0 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; ── First part of x: ── #&gt; # A tibble: 7 × 4 #&gt; time amt ii evid #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;evid&gt; #&gt; 1 0 50 0 1:Dose (Add) #&gt; 2 8 50 0 1:Dose (Add) #&gt; 3 16 50 0 1:Dose (Add) #&gt; 4 24 50 0 1:Dose (Add) #&gt; 5 32 50 0 1:Dose (Add) #&gt; 6 40 50 0 1:Dose (Add) #&gt; 7 48 50 0 1:Dose (Add) 我们可以看到addl事件被展开了，但是原始数据帧保持不变: print(ev) #&gt; ── EventTable with 1 records ── #&gt; 1 dosing records (see $get.dosing(); add with add.dosing or #&gt; et) #&gt; 0 observation times (see $get.sampling(); add with #&gt; add.sampling or et) #&gt; multiple doses in `addl` columns, expand with $expand(); or #&gt; etExpand() #&gt; ── First part of : ── #&gt; # A tibble: 1 × 5 #&gt; time amt ii addl evid #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;evid&gt; #&gt; 1 0 50 8 6 1:Dose (Add) 第二种方式，如果您使用ev$expand()展开，它将修改ev对象。这是类似于面向对象的方法： ev$expand() ev #&gt; ── EventTable with 7 records ── #&gt; 7 dosing records (see x$get.dosing(); add with add.dosing #&gt; or et) #&gt; 0 observation times (see x$get.sampling(); add with #&gt; add.sampling or et) #&gt; ── First part of x: ── #&gt; # A tibble: 7 × 4 #&gt; time amt ii evid #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;evid&gt; #&gt; 1 0 50 0 1:Dose (Add) #&gt; 2 8 50 0 1:Dose (Add) #&gt; 3 16 50 0 1:Dose (Add) #&gt; 4 24 50 0 1:Dose (Add) #&gt; 5 32 50 0 1:Dose (Add) #&gt; 6 40 50 0 1:Dose (Add) #&gt; 7 48 50 0 1:Dose (Add) 8.10RStudio笔记本中的事件表 除了上述示例中显示的控制台中的输出之外，RStudio笔记本的输出也有所不同，可以在以下屏幕截图中看到; 第一个屏幕截图显示了在Rstduio笔记本中评估事件表后的外观 这是一个简单的数据框，允许您翻阅内容。如果您单击Rstduio笔记本输出中的第一个框，它将包含有关事件表的注释： "],["第九章求解和求解选项.html", "第九章求解和求解选项 9.1 一般的求解选项", " 第九章求解和求解选项 通常，常微分方程(ODE)是使用以下组合求解的： 来自rxode2()的已编译模型描述，使用Object=指定 输入参数，使用params=指定（可以为空） 输入数据或事件表，使用events=指定 初始条件，使用inits=指定（并且可能在模型本身中由state(0)=指定) 以下各节给出了求解选项的说明： 9.1 一般的求解选项 9.1.1 rxControl rxControl 输入列表或 rxControl类型的列表 ### sensCmt 敏感性房室数量### ncmt 房室数量 【译者注：此页面似乎作者也还未完工，rxControl的详细介绍可参见rxode2包网站页】 "],["第十章rxode2的输出.html", "第十章rxode2的输出 10.1使用rxode2数据框 10.2交互式更新数据集", " 第十章rxode2的输出 10.1使用rxode2数据框 10.1.1创建交互式数据框 rxode2支持返回已求解的对象，该对象是一个修改后的数据帧。 这是由predict()、solve()或rxSolve()方法完成的。 library(rxode2) library(units) ### Setup example model mod1 &lt;- rxode2({ C2 = centr/V2; C3 = peri/V3; d/dt(depot) =-KA*depot; d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; }) ### Seup parameters and initial conditions theta &lt;- c(KA=2.94E-01, CL=1.86E+01, V2=4.02E+01, # central Q=1.05E+01, V3=2.97E+02, # peripheral Kin=1, Kout=1, EC50=200) # effects inits &lt;- c(eff=1) ### Setup dosing event information ev &lt;- eventTable(amount.units=&quot;mg&quot;, time.units=&quot;hours&quot;) %&gt;% add.dosing(dose=10000, nbr.doses=10, dosing.interval=12) %&gt;% add.dosing(dose=20000, nbr.doses=5, start.time=120, dosing.interval=24) %&gt;% add.sampling(0:240); ### Now solve x &lt;- predict(mod1,theta, ev, inits) print(x) #&gt; ── Solved rxode2 object ── #&gt; ── Parameters ($params): ── #&gt; V2 V3 KA CL Q Kin Kout EC50 #&gt; 40.200 297.000 0.294 18.600 10.500 1.000 1.000 200.000 #&gt; ── Initial Conditions ($inits): ── #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; ── First part of data (object): ── #&gt; # A tibble: 241 × 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 1 #&gt; 2 1 44.4 0.920 7453. 1784. 273. 1.08 #&gt; 3 2 54.9 2.67 5554. 2206. 794. 1.18 #&gt; 4 3 51.9 4.46 4140. 2087. 1324. 1.23 #&gt; 5 4 44.5 5.98 3085. 1789. 1776. 1.23 #&gt; 6 5 36.5 7.18 2299. 1467. 2132. 1.21 #&gt; # … with 235 more rows 或者 x &lt;- solve(mod1,theta, ev, inits) print(x) #&gt; ── Solved rxode2 object ── #&gt; ── Parameters ($params): ── #&gt; V2 V3 KA CL Q Kin Kout EC50 #&gt; 40.200 297.000 0.294 18.600 10.500 1.000 1.000 200.000 #&gt; ── Initial Conditions ($inits): ── #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; ── First part of data (object): ── #&gt; # A tibble: 241 × 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 1 #&gt; 2 1 44.4 0.920 7453. 1784. 273. 1.08 #&gt; 3 2 54.9 2.67 5554. 2206. 794. 1.18 #&gt; 4 3 51.9 4.46 4140. 2087. 1324. 1.23 #&gt; 5 4 44.5 5.98 3085. 1789. 1776. 1.23 #&gt; 6 5 36.5 7.18 2299. 1467. 2132. 1.21 #&gt; # … with 235 more rows 或者和mattigr的管道操作符一起使用 x &lt;- mod1 %&gt;% solve(theta, ev, inits) print(x) #&gt; ── Solved rxode2 object ── #&gt; ── Parameters ($params): ── #&gt; V2 V3 KA CL Q Kin Kout EC50 #&gt; 40.200 297.000 0.294 18.600 10.500 1.000 1.000 200.000 #&gt; ── Initial Conditions ($inits): ── #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; ── First part of data (object): ── #&gt; # A tibble: 241 × 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 1 #&gt; 2 1 44.4 0.920 7453. 1784. 273. 1.08 #&gt; 3 2 54.9 2.67 5554. 2206. 794. 1.18 #&gt; 4 3 51.9 4.46 4140. 2087. 1324. 1.23 #&gt; 5 4 44.5 5.98 3085. 1789. 1776. 1.23 #&gt; 6 5 36.5 7.18 2299. 1467. 2132. 1.21 #&gt; # … with 235 more rows 10.1.2rxode2已求解对象的属性 10.1.3使用已求解的对象作为简单的数据帧 已求解的对象作为data.frame或tbl可以通过dpylr添加包对数据进行筛选。例如，您可以轻松的对其进行筛选。 library(dplyr) #&gt; #&gt; Attaching package: &#39;dplyr&#39; #&gt; The following objects are masked from &#39;package:stats&#39;: #&gt; #&gt; filter, lag #&gt; The following objects are masked from &#39;package:base&#39;: #&gt; #&gt; intersect, setdiff, setequal, union ### You can drop units for comparisons and filtering x &lt;- mod1 %&gt;% solve(theta,ev,inits) %&gt;% drop_units %&gt;% filter(time &lt;= 3) %&gt;% as.tbl #&gt; Warning: `as.tbl()` was deprecated in dplyr 1.0.0. #&gt; ℹ Please use `tibble::as_tibble()` instead. ### or keep them and compare with the proper units. x &lt;- mod1 %&gt;% solve(theta,ev,inits) %&gt;% filter(time &lt;= set_units(3, hr)) %&gt;% as.tbl x #&gt; # A tibble: 4 × 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 1 #&gt; 2 1 44.4 0.920 7453. 1784. 273. 1.08 #&gt; 3 2 54.9 2.67 5554. 2206. 794. 1.18 #&gt; 4 3 51.9 4.46 4140. 2087. 1324. 1.23 10.2交互式更新数据集 然而，它不仅仅是一个简单的数据对象。您可以使用已求解的对象动态更新参数，甚至修改采样时间。 首先，我们需要重新创建原始已求解的系统： x &lt;- mod1 %&gt;% solve(theta,ev,inits); print(x) #&gt; ── Solved rxode2 object ── #&gt; ── Parameters ($params): ── #&gt; V2 V3 KA CL Q Kin Kout EC50 #&gt; 40.200 297.000 0.294 18.600 10.500 1.000 1.000 200.000 #&gt; ── Initial Conditions ($inits): ── #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; ── First part of data (object): ── #&gt; # A tibble: 241 × 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 1 #&gt; 2 1 44.4 0.920 7453. 1784. 273. 1.08 #&gt; 3 2 54.9 2.67 5554. 2206. 794. 1.18 #&gt; 4 3 51.9 4.46 4140. 2087. 1324. 1.23 #&gt; 5 4 44.5 5.98 3085. 1789. 1776. 1.23 #&gt; 6 5 36.5 7.18 2299. 1467. 2132. 1.21 #&gt; # … with 235 more rows 10.2.1修改初始条件 要检查或更改初始条件，您可以使用语法 cmt.0、cmt0或cmt_0。在模型定义eff房室的情况下，可以这样操作： x$eff0 #&gt; [1] 1 它显示eff房室的初始条件。如果您希望将此初始条件修改为2，可以通过以下方式轻松完成： x$eff0 &lt;- 2 print(x) #&gt; ── Solved rxode2 object ── #&gt; ── Parameters ($params): ── #&gt; V2 V3 KA CL Q Kin Kout EC50 #&gt; 40.200 297.000 0.294 18.600 10.500 1.000 1.000 200.000 #&gt; ── Initial Conditions ($inits): ── #&gt; depot centr peri eff #&gt; 0 0 0 2 #&gt; ── First part of data (object): ── #&gt; # A tibble: 241 × 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 2 #&gt; 2 1 44.4 0.920 7453. 1784. 273. 1.50 #&gt; 3 2 54.9 2.67 5554. 2206. 794. 1.37 #&gt; 4 3 51.9 4.46 4140. 2087. 1324. 1.31 #&gt; 5 4 44.5 5.98 3085. 1789. 1776. 1.27 #&gt; 6 5 36.5 7.18 2299. 1467. 2132. 1.23 #&gt; # … with 235 more rows plot(x) 10.2.2修改rxode2的观测时间 请注意，eff房室的初始条件现在是2。 您还可以通过修改t或time轻松修改采样时间。例如： x$t &lt;- seq(0,5,length.out=20) print(x) #&gt; ── Solved rxode2 object ── #&gt; ── Parameters ($params): ── #&gt; V2 V3 KA CL Q Kin Kout EC50 #&gt; 40.200 297.000 0.294 18.600 10.500 1.000 1.000 200.000 #&gt; ── Initial Conditions ($inits): ── #&gt; depot centr peri eff #&gt; 0 0 0 2 #&gt; ── First part of data (object): ── #&gt; # A tibble: 20 × 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 2 #&gt; 2 0.263 16.8 0.0817 9255. 677. 24.3 1.79 #&gt; 3 0.526 29.5 0.299 8566. 1187. 88.7 1.65 #&gt; 4 0.789 38.9 0.615 7929. 1562. 183. 1.55 #&gt; 5 1.05 45.5 1.00 7338. 1830. 298. 1.49 #&gt; 6 1.32 50.1 1.44 6792. 2013. 427. 1.44 #&gt; # … with 14 more rows plot(x) 10.2.3修改仿真参数 您还可以通过$操作符访问或修改参数。例如，对于KA可以通过以下方式访问： x$KA #&gt; [1] 0.294 您可以通过为其赋值一个新值来修改它。 x$KA &lt;- 1 print(x) #&gt; ── Solved rxode2 object ── #&gt; ── Parameters ($params): ── #&gt; V2 V3 KA CL Q Kin Kout EC50 #&gt; 40.2 297.0 1.0 18.6 10.5 1.0 1.0 200.0 #&gt; ── Initial Conditions ($inits): ── #&gt; depot centr peri eff #&gt; 0 0 0 2 #&gt; ── First part of data (object): ── #&gt; # A tibble: 20 × 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 2 #&gt; 2 0.263 52.2 0.261 7686. 2098. 77.6 1.82 #&gt; 3 0.526 83.3 0.900 5908. 3348. 267. 1.74 #&gt; 4 0.789 99.8 1.75 4541. 4010. 519. 1.69 #&gt; 5 1.05 106. 2.69 3490. 4273. 800. 1.67 #&gt; 6 1.32 106. 3.66 2683. 4272. 1086. 1.64 #&gt; # … with 14 more rows plot(x) 您可以使用$params、$inits、$events来访问/修改所有参数、初始化或事件，语法类似与上面使用。 这种语法使得更新和探索各种参数对已求解对象的影响变得容易。 "],["第十一章模拟.html", "第十一章模拟 11.1单一个体的求解 11.2使用rxode2进行群体模拟 11.3模拟临床试验 11.4使用先验数据进行求解", " 第十一章模拟 11.1单一个体的求解 最初，创建rxode2只是为了求解一个个体的ODE。这是一个单独的系统，不会对各个参数进行任何更改。 当然这在目前仍然是支持的，经典的例子可以在 rxode2介绍中找到。 本文讨论了多个个体和单一个体求解的区别，有三个区别： 单一求解不会并行求解每个ID 单一求解在参数($params)和实际数据集中缺少id列。 单一求解允许更轻松地探索参数，因为每个参数都可以修改。对于多个个体求解，您必须确保更新每个单独的参数。 第一个明显的区别是速度;对于多个个体，你可以并行运行每个个体ID。有关多个体求解速度提高的更多信息和示例，参阅rxdoe添加包的加速rxode2插图。 下一个区别是最终数据中输出的信息量。 以教程中最初的2房室间接效应模型为例： library(rxode2) mod1 &lt;-rxode2({ KA=2.94E-01 CL=1.86E+01 V2=4.02E+01 Q=1.05E+01 V3=2.97E+02 Kin=1 Kout=1 EC50=200 C2 = centr/V2 C3 = peri/V3 d/dt(depot) =-KA*depot d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3 d/dt(peri) = Q*C2 - Q*C3 d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff eff(0) = 1 }) et &lt;- et(amount.units=&#39;mg&#39;, time.units=&#39;hours&#39;) %&gt;% et(dose=10000, addl=9, ii=12) %&gt;% et(amt=20000, nbr.doses=5, start.time=120, dosing.interval=24) %&gt;% et(0:240) # sampling 现在进行一个简单的求解 x &lt;- rxSolve(mod1, et) x #&gt; ── Solved rxode2 object ── #&gt; ── Parameters (x$params): ── #&gt; KA CL V2 Q V3 Kin Kout EC50 #&gt; 0.294 18.600 40.200 10.500 297.000 1.000 1.000 200.000 #&gt; ── Initial Conditions (x$inits): ── #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; ── First part of data (object): ── #&gt; # A tibble: 241 × 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 1 #&gt; 2 1 44.4 0.920 7453. 1784. 273. 1.08 #&gt; 3 2 54.9 2.67 5554. 2206. 794. 1.18 #&gt; 4 3 51.9 4.46 4140. 2087. 1324. 1.23 #&gt; 5 4 44.5 5.98 3085. 1789. 1776. 1.23 #&gt; 6 5 36.5 7.18 2299. 1467. 2132. 1.21 #&gt; # … with 235 more rows print(x) #&gt; ── Solved rxode2 object ── #&gt; ── Parameters ($params): ── #&gt; KA CL V2 Q V3 Kin Kout EC50 #&gt; 0.294 18.600 40.200 10.500 297.000 1.000 1.000 200.000 #&gt; ── Initial Conditions ($inits): ── #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; ── First part of data (object): ── #&gt; # A tibble: 241 × 7 #&gt; time C2 C3 depot centr peri eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 0 10000 0 0 1 #&gt; 2 1 44.4 0.920 7453. 1784. 273. 1.08 #&gt; 3 2 54.9 2.67 5554. 2206. 794. 1.18 #&gt; 4 3 51.9 4.46 4140. 2087. 1324. 1.23 #&gt; 5 4 44.5 5.98 3085. 1789. 1776. 1.23 #&gt; 6 5 36.5 7.18 2299. 1467. 2132. 1.21 #&gt; # … with 235 more rows plot(x, C2, eff) 为了更好地看到单一个体求解之间的差异，您可以解决2个个体 x2 &lt;- rxSolve(mod1, et %&gt;% et(id=1:2), params=data.frame(CL=c(18.6, 7.6))) print(x2) #&gt; ── Solved rxode2 object ── #&gt; ── Parameters ($params): ── #&gt; # A tibble: 2 × 9 #&gt; id KA CL V2 Q V3 Kin Kout EC50 #&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 0.294 18.6 40.2 10.5 297 1 1 200 #&gt; 2 2 0.294 7.6 40.2 10.5 297 1 1 200 #&gt; ── Initial Conditions ($inits): ── #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; ── First part of data (object): ── #&gt; # A tibble: 482 × 8 #&gt; id time C2 C3 depot centr peri eff #&gt; &lt;int&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 0 0 0 10000 0 0 1 #&gt; 2 1 1 44.4 0.920 7453. 1784. 273. 1.08 #&gt; 3 1 2 54.9 2.67 5554. 2206. 794. 1.18 #&gt; 4 1 3 51.9 4.46 4140. 2087. 1324. 1.23 #&gt; 5 1 4 44.5 5.98 3085. 1789. 1776. 1.23 #&gt; 6 1 5 36.5 7.18 2299. 1467. 2132. 1.21 #&gt; # … with 476 more rows plot(x2, C2, eff) 通过观察这两个求解结果，您可以看到： 多个个体的求解结果包含数据框中的id列，然后是每个个体的参数的数据框。 最后一个不那么明显的特征，修改个体参数。对于单一个体的数据，可以通过修改rxode2数据框改变初始条件和参数值，就好像它们是数据帧的一部分，如rxode2数据框中所述。 对于多个个体求解，此功能仍然有效，但在提供每个个体的参数值时需要小心，否则您可能会不小心修改了关键个体的求解和删除参数。 11.1.1单一个体求解与多个个体求解的总结 特征 单一个体求解 多个个体求解 并行 无 每个个体 \\(params | data.frame带有一组参数值 | data.frame带有每个个体的一组参数（w/ID列） | | 已求解后的数据 | 可以用\\)语法修改单个参数 必须修改所有参数来更新已求解的对象 11.2使用rxode2进行群体模拟 11.2.1使用rxode2模拟变异性 在定量药理学中，非线性混合效应建模软件（如nlmixr）表征受试者之间的变异。有了这个受试者之间的变异，您可以模拟新的受试者。 假设您有一个2房室的间接效应模型，您可以在下面设置创建一个描述该系统的rxode2模型： 11.2.1.1设置rxode2模型 library(rxode2) set.seed(32) rxSetSeed(32) mod &lt;- rxode2({ eff(0) = 1 C2 = centr/V2*(1+prop.err); C3 = peri/V3; CL = TCl*exp(eta.Cl) ## This is coded as a variable in the model d/dt(depot) =-KA*depot; d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; }) 11.2.1.2添加参数估计值 下一步是将参数输入R，以便您可以开始模拟： theta &lt;- c(KA=2.94E-01, TCl=1.86E+01, V2=4.02E+01, # central Q=1.05E+01, V3=2.97E+02, # peripheral Kin=1, Kout=1, EC50=200, prop.err=0) # effects 在这种情况下，我使用lotri来指定omega，因为它使用与nlmixr类似（也类似于 NONMEM）的下三角矩阵规范： ### the column names of the omega matrix need to match the parameters specified by rxode2 omega &lt;- lotri(eta.Cl ~ 0.4^2) omega #&gt; eta.Cl #&gt; eta.Cl 0.16 11.2.1.3模拟 模拟的下一步是为整体模拟创建给药方案： ev &lt;- et(amount.units=&quot;mg&quot;, time.units=&quot;hours&quot;) %&gt;% et(amt=10000, cmt=&quot;centr&quot;) 如果您愿意，您还可以添加采样时间（尽管现在rxode2可以为您填写这些时间）： ev &lt;- ev %&gt;% et(0,48, length.out=100) 注意当添加采样时间时，et使用与seq类似的参数。有很多种的方法可以用来增加采样时间和事件，以实现使复杂的给药方案(见事件插图)。这包括在采样和给药时间两者上增加变异的方法。 一旦上述操作都完成后，您可以使用rxSolve进行模拟： sim &lt;- rxSolve(mod,theta,ev,omega=omega,nSub=100) 要快速查看和自定义模拟，您可以使用默认 plot程序。因为这是一个rxode2对象，所以它将创建一个 ggplot2对象，您可以根据需要随意修改此ggplot2对象。plot的额外参数告诉rxode2/R您对绘图感兴趣的信息。在本例中，我们感兴趣的是查看衍生出的参数C2： 11.2.1.4通过plot检查模拟 library(ggplot2) ### The plots from rxode2 are ggplots so they can be modified with ### standard ggplot commands. plot(sim, C2, log=&quot;y&quot;) + ylab(&quot;Central Compartment&quot;) 当然，这个额外附加参数也可以是一个状态值，比如eff： ### They also takes many of the standard plot arguments; See ?plot plot(sim, eff, ylab=&quot;Effect&quot;) 或者，你甚至可以并排同时查看这两个： plot(sim, C2, eff) 或者，可以通过patchwork把他们堆积起来： library(patchwork) plot(sim, C2, log=&quot;y&quot;) / plot(sim, eff) 11.2.1.5处理数据以创建摘要图 通常在定量药理学模拟中，仅仅模拟系统是不够的。我们必须做一些更容易理解的事情，比如观察模拟的中心和极端趋势。 由于rxode2对象是一种数据框 因此现在可以直接使用模拟数据执行计算和生成绘图。您可以 以下代码，绘制了模拟数据的第5、50和95个百分位数。 confint(sim, &quot;C2&quot;, level=0.95) %&gt;% plot(ylab=&quot;Central Concentration&quot;, log=&quot;y&quot;) #&gt; ! in order to put confidence bands around the intervals, you need at least 2500 simulations #&gt; summarizing data...done confint(sim, &quot;eff&quot;, level=0.95) %&gt;% plot(ylab=&quot;Effect&quot;) #&gt; ! in order to put confidence bands around the intervals, you need at least 2500 simulations #&gt; summarizing data...done 请注意，您可以看到为该示例模拟的参数 head(sim$param) #&gt; sim.id V2 prop.err V3 TCl eta.Cl KA Q Kin Kout EC50 #&gt; 1 1 40.2 0 297 18.6 -0.2332273 0.294 10.5 1 1 200 #&gt; 2 2 40.2 0 297 18.6 -0.3097188 0.294 10.5 1 1 200 #&gt; 3 3 40.2 0 297 18.6 -0.1103929 0.294 10.5 1 1 200 #&gt; 4 4 40.2 0 297 18.6 0.3790298 0.294 10.5 1 1 200 #&gt; 5 5 40.2 0 297 18.6 -0.2001559 0.294 10.5 1 1 200 #&gt; 6 6 40.2 0 297 18.6 0.1855595 0.294 10.5 1 1 200 11.2.1.6无法解释的变异（sigma）的模拟 除了方便地模拟个体之间的变异，您还可以轻松模拟无法解释的变异【译者注：这里是指残差变异，残差变异又被称之为剩余的无法解释的变异】。 mod &lt;- rxode2({ eff(0) = 1 C2 = centr/V2; C3 = peri/V3; CL = TCl*exp(eta.Cl) ## This is coded as a variable in the model d/dt(depot) =-KA*depot; d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; e = eff+eff.err cp = centr*(1+cp.err) }) theta &lt;- c(KA=2.94E-01, TCl=1.86E+01, V2=4.02E+01, # central Q=1.05E+01, V3=2.97E+02, # peripheral Kin=1, Kout=1, EC50=200) # effects sigma &lt;- lotri(eff.err ~ 0.1, cp.err ~ 0.1) sim &lt;- rxSolve(mod, theta, ev, omega=omega, nSub=100, sigma=sigma) s &lt;- confint(sim, c(&quot;eff&quot;, &quot;centr&quot;)); #&gt; ! in order to put confidence bands around the intervals, you need at least 2500 simulations #&gt; summarizing data...done plot(s) 11.2.1.7模拟个体 有时您可能想要在临床试验中匹配个体的剂量和观察结果。要做到这一点，您必须使用rxode2事件规范 创建一个data.Frame，以及创建一个ID列来指示个体。rxode2的事件插图详细介绍了应该如何创建这些数据集。 library(dplyr) ev1 &lt;- eventTable(amount.units=&quot;mg&quot;, time.units=&quot;hours&quot;) %&gt;% add.dosing(dose=10000, nbr.doses=1, dosing.to=2) %&gt;% add.sampling(seq(0,48,length.out=10)); ev2 &lt;- eventTable(amount.units=&quot;mg&quot;, time.units=&quot;hours&quot;) %&gt;% add.dosing(dose=5000, nbr.doses=1, dosing.to=2) %&gt;% add.sampling(seq(0,48,length.out=8)); dat &lt;- rbind(data.frame(ID=1, ev1$get.EventTable()), data.frame(ID=2, ev2$get.EventTable())) ### Note the number of subject is not needed since it is determined by the data sim &lt;- rxSolve(mod, theta, dat, omega=omega, sigma=sigma) sim %&gt;% select(id, time, e, cp) #&gt; id time e cp #&gt; 1 1 0.000000 [h] 1.0444940 5227.28602 #&gt; 2 1 5.333333 [h] 0.7186017 513.87177 #&gt; 3 1 10.666667 [h] 1.2883307 101.02653 #&gt; 4 1 16.000000 [h] 0.8259603 106.42998 #&gt; 5 1 21.333333 [h] 0.8209345 197.54042 #&gt; 6 1 26.666667 [h] 1.1566976 103.53138 #&gt; 7 1 32.000000 [h] 1.1361974 151.14445 #&gt; 8 1 37.333333 [h] 0.8207058 150.22830 #&gt; 9 1 42.666667 [h] 0.7685176 81.82299 #&gt; 10 1 48.000000 [h] 1.0482719 76.25287 #&gt; 11 2 0.000000 [h] 0.6760207 4393.70285 #&gt; 12 2 6.857143 [h] 0.9278252 64.17252 #&gt; 13 2 13.714286 [h] 1.7870333 49.54396 #&gt; 14 2 20.571429 [h] 0.8339921 38.91878 #&gt; 15 2 27.428571 [h] 0.8989828 32.64892 #&gt; 16 2 34.285714 [h] 0.9293400 25.13497 #&gt; 17 2 41.142857 [h] 1.3691292 21.36848 #&gt; 18 2 48.000000 [h] 0.5910913 5.68595 11.3模拟临床试验 通过使用简单的单一事件表或来自上述临床试验的数据，可以执行完整的临床试验模拟。 通常在临床试验模拟中，您希望考虑固定效应参数估计中的不确定性【译者注：这里的不确定性是指参数估计的精度，以及精度的方差协方差矩阵;参数估计的精度不仅固定效应参数有，个体间变异和个体内变异等参数也存在其对应的精度的方差协方差矩阵;初学者容易将不确定性的方差协方差矩阵与描述个体间变异OMEGA(OMEGA矩阵也是一种方差协方差矩阵)混淆，读者应区分并知悉这是两种不同的东西】，甚至包括受试者之间的变异以及无法解释的变异的不确定性。 rxode2允许您在模拟时通过参数nStud指定多个虚拟“研究”进行模拟，来解释这些不确定性 。这些研究中的每一项都对个体间变异omega)和未解释变异(sigma)之间的固定效应效应参数和协方差矩阵的实现进行了采样。根据你从模型中得到的信息，有几种策略可用于模拟omega和sigma矩阵的实现。 第一种策略，在标准差(或相关参数)没有任何标准误时，或者在您所模拟的模型中存在参数间相关性时，采用此策略。在这种情况下，建议的策略是使用逆Wishart（参数化以缩放到共轭先验）/缩放逆chi分布。 这种方法使用单个参数来告知 采样的协方差矩阵的变异性（自由度）。 第二种策略，如果您在方差/标准差上有标准误，而协方差矩阵中没有参数间相关性，采用此策略。在这种方法中，您可以分别对标准差和相关矩阵进行模拟。首先，在thetaMat多元正态模拟中模拟方差/标准差分量。在模拟并转换为标准差后，将使用协方差矩阵的自由度来模拟相关矩阵。将模拟的标准差与模拟的相关矩阵相结合后将得到一个模拟的协方差矩阵。对于较小维度的协方差矩阵 （尺寸&lt;10x10）建议您使用lkj分布来模拟相关矩阵。对于更高维度的协方差矩阵，建议您使用逆wishart分布(转换为相关矩阵)进行模拟。 协方差/方差先验是由rxode2的cvPost() 函数模拟的。 11.3.1基于逆Wishart相关性的模拟 此模拟的示例如下： ### Creating covariance matrix tmp &lt;- matrix(rnorm(8^2), 8, 8) tMat &lt;- tcrossprod(tmp, tmp) / (8 ^ 2) dimnames(tMat) &lt;- list(NULL, names(theta)) sim &lt;- rxSolve(mod, theta, ev, omega=omega, nSub=100, sigma=sigma, thetaMat=tMat, nStud=10, dfSub=10, dfObs=100) s &lt;-sim %&gt;% confint(c(&quot;centr&quot;, &quot;eff&quot;)) #&gt; summarizing data...done plot(s) 如果你想查看每个虚拟研究中使用的omega和sigma，请通过使用$omega.list和$sigma.list在已求解的数据对象中访问它们 ： head(sim$omega.list) #&gt; [[1]] #&gt; eta.Cl #&gt; eta.Cl 0.1676778 #&gt; #&gt; [[2]] #&gt; eta.Cl #&gt; eta.Cl 0.2917085 #&gt; #&gt; [[3]] #&gt; eta.Cl #&gt; eta.Cl 0.1776813 #&gt; #&gt; [[4]] #&gt; eta.Cl #&gt; eta.Cl 0.1578682 #&gt; #&gt; [[5]] #&gt; eta.Cl #&gt; eta.Cl 0.1845614 #&gt; #&gt; [[6]] #&gt; eta.Cl #&gt; eta.Cl 0.3282268 head(sim$sigma.list) #&gt; [[1]] #&gt; eff.err cp.err #&gt; eff.err 0.112416983 0.004197039 #&gt; cp.err 0.004197039 0.097293971 #&gt; #&gt; [[2]] #&gt; eff.err cp.err #&gt; eff.err 0.084311199 -0.006277998 #&gt; cp.err -0.006277998 0.122140938 #&gt; #&gt; [[3]] #&gt; eff.err cp.err #&gt; eff.err 0.09834771 0.01060251 #&gt; cp.err 0.01060251 0.10024751 #&gt; #&gt; [[4]] #&gt; eff.err cp.err #&gt; eff.err 0.125556975 0.007690868 #&gt; cp.err 0.007690868 0.090991261 #&gt; #&gt; [[5]] #&gt; eff.err cp.err #&gt; eff.err 0.1116261 -0.0184748 #&gt; cp.err -0.0184748 0.1320288 #&gt; #&gt; [[6]] #&gt; eff.err cp.err #&gt; eff.err 0.093539238 0.007270049 #&gt; cp.err 0.007270049 0.098648424 您还可以从$params数据框中看到参数实现。 11.3.2使用方差/标准差标准误差进行模拟 假设我们希望模拟xpose中包含的nonmem运行 首先我们设置模型: rx1 &lt;- rxode2({ cl &lt;- tcl*(1+crcl.cl*(CLCR-65)) * exp(eta.cl) v &lt;- tv * WT * exp(eta.v) ka &lt;- tka * exp(eta.ka) ipred &lt;- linCmt() obs &lt;- ipred * (1 + prop.sd) + add.sd }) 接下来我们输入参数的估计值： theta &lt;- c(tcl=2.63E+01, tv=1.35E+00, tka=4.20E+00, tlag=2.08E-01, prop.sd=2.05E-01, add.sd=1.06E-02, crcl.cl=7.17E-03, ## Note that since we are using the separation strategy the ETA variances are here too eta.cl=7.30E-02, eta.v=3.80E-02, eta.ka=1.91E+00) 以及它们的协方差;对我来说，创建命名协方差矩阵的最简单方法是使用lotri()： thetaMat &lt;- lotri( tcl + tv + tka + tlag + prop.sd + add.sd + crcl.cl + eta.cl + eta.v + eta.ka ~ c(7.95E-01, 2.05E-02, 1.92E-03, 7.22E-02, -8.30E-03, 6.55E-01, -3.45E-03, -6.42E-05, 3.22E-03, 2.47E-04, 8.71E-04, 2.53E-04, -4.71E-03, -5.79E-05, 5.04E-04, 6.30E-04, -3.17E-06, -6.52E-04, -1.53E-05, -3.14E-05, 1.34E-05, -3.30E-04, 5.46E-06, -3.15E-04, 2.46E-06, 3.15E-06, -1.58E-06, 2.88E-06, -1.29E-03, -7.97E-05, 1.68E-03, -2.75E-05, -8.26E-05, 1.13E-05, -1.66E-06, 1.58E-04, -1.23E-03, -1.27E-05, -1.33E-03, -1.47E-05, -1.03E-04, 1.02E-05, 1.67E-06, 6.68E-05, 1.56E-04, 7.69E-02, -7.23E-03, 3.74E-01, 1.79E-03, -2.85E-03, 1.18E-05, -2.54E-04, 1.61E-03, -9.03E-04, 3.12E-01)) evw &lt;- et(amount.units=&quot;mg&quot;, time.units=&quot;hours&quot;) %&gt;% et(amt=100) %&gt;% ## For this problem we will simulate with sampling windows et(list(c(0, 0.5), c(0.5, 1), c(1, 3), c(3, 6), c(6, 12))) %&gt;% et(id=1:1000) ### From the run we know that: ### total number of observations is: 476 ### Total number of individuals: 74 sim &lt;- rxSolve(rx1, theta, evw, nSub=100, nStud=10, thetaMat=thetaMat, ## Match boundaries of problem thetaLower=0, sigma=c(&quot;prop.sd&quot;, &quot;add.sd&quot;), ## Sigmas are standard deviations sigmaXform=&quot;identity&quot;, # default sigma xform=&quot;identity&quot; omega=c(&quot;eta.cl&quot;, &quot;eta.v&quot;, &quot;eta.ka&quot;), ## etas are variances omegaXform=&quot;variance&quot;, # default omega xform=&quot;variance&quot; iCov=data.frame(WT=rnorm(1000, 70, 15), CLCR=rnorm(1000, 65, 25)), dfSub=74, dfObs=476); #&gt; ℹ thetaMat has too many items, ignored: &#39;tlag&#39; print(sim) #&gt; ── Solved rxode2 object ── #&gt; ── Parameters ($params): ── #&gt; # A tibble: 10,000 × 9 #&gt; sim.id id tcl crcl.cl eta.cl tv eta.v tka eta.ka #&gt; &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 26.7 2.27 0.0525 2.52 0.692 4.83 -2.16 #&gt; 2 1 2 26.7 2.27 0.0383 2.52 -0.226 4.83 -1.49 #&gt; 3 1 3 26.7 2.27 0.207 2.52 0.346 4.83 0.939 #&gt; 4 1 4 26.7 2.27 -0.0993 2.52 -0.0124 4.83 -0.299 #&gt; 5 1 5 26.7 2.27 -0.308 2.52 -0.277 4.83 0.703 #&gt; 6 1 6 26.7 2.27 0.0300 2.52 0.278 4.83 1.36 #&gt; 7 1 7 26.7 2.27 0.0196 2.52 0.0696 4.83 -0.0215 #&gt; 8 1 8 26.7 2.27 -0.233 2.52 0.0493 4.83 -0.573 #&gt; 9 1 9 26.7 2.27 0.693 2.52 0.277 4.83 -0.161 #&gt; 10 1 10 26.7 2.27 -0.0748 2.52 0.206 4.83 -0.296 #&gt; # … with 9,990 more rows #&gt; ── Initial Conditions ($inits): ── #&gt; named numeric(0) #&gt; #&gt; Simulation with uncertainty in: #&gt; • parameters ($thetaMat for changes) #&gt; • omega matrix ($omegaList) #&gt; • sigma matrix ($sigmaList) #&gt; #&gt; ── First part of data (object): ── #&gt; # A tibble: 50,000 × 10 #&gt; sim.id id time cl v ka ipred obs WT CLCR #&gt; &lt;int&gt; &lt;int&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 0.0155 301. 313. 0.559 0.00274 -3.08 62.2 69.3 #&gt; 2 1 1 0.749 301. 313. 0.559 0.0760 0.736 62.2 69.3 #&gt; 3 1 1 1.02 301. 313. 0.559 0.0845 -2.18 62.2 69.3 #&gt; 4 1 1 3.41 301. 313. 0.559 0.0493 1.36 62.2 69.3 #&gt; 5 1 1 7.81 301. 313. 0.559 0.00540 2.30 62.2 69.3 #&gt; 6 1 2 0.0833 2582. 71.7 1.09 0.0376 -0.0849 35.7 105. #&gt; # … with 49,994 more rows ### Notice that the simulation time-points change for the individual ### If you want the same sampling time-points you can do that as well: evw &lt;- et(amount.units=&quot;mg&quot;, time.units=&quot;hours&quot;) %&gt;% et(amt=100) %&gt;% et(0, 24, length.out=50) %&gt;% et(id=1:100) sim &lt;- rxSolve(rx1, theta, evw, nSub=100, nStud=10, thetaMat=thetaMat, ## Match boundaries of problem thetaLower=0, sigma=c(&quot;prop.sd&quot;, &quot;add.sd&quot;), ## Sigmas are standard deviations sigmaXform=&quot;identity&quot;, # default sigma xform=&quot;identity&quot; omega=c(&quot;eta.cl&quot;, &quot;eta.v&quot;, &quot;eta.ka&quot;), ## etas are variances omegaXform=&quot;variance&quot;, # default omega xform=&quot;variance&quot; iCov=data.frame(WT=rnorm(100, 70, 15), CLCR=rnorm(100, 65, 25)), dfSub=74, dfObs=476, resample=TRUE) #&gt; ℹ thetaMat has too many items, ignored: &#39;tlag&#39; s &lt;-sim %&gt;% confint(c(&quot;ipred&quot;)) #&gt; summarizing data... #&gt; done plot(s) 11.3.3omega或sigma参数没有不确定性的进行模拟 如果您不希望从omega或sigma矩阵的任一先验分布中抽样，则您可以通过在求解时指定simVariability = FALSE选项，以下方式关闭此功能 ： mod &lt;- rxode2({ eff(0) = 1 C2 = centr/V2; C3 = peri/V3; CL = TCl*exp(eta.Cl) ## This is coded as a variable in the model d/dt(depot) =-KA*depot; d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; e = eff+eff.err cp = centr*(1+cp.err) }) theta &lt;- c(KA=2.94E-01, TCl=1.86E+01, V2=4.02E+01, # central Q=1.05E+01, V3=2.97E+02, # peripheral Kin=1, Kout=1, EC50=200) # effects sigma &lt;- lotri(eff.err ~ 0.1, cp.err ~ 0.1) sim &lt;- rxSolve(mod, theta, ev, omega=omega, nSub=100, sigma=sigma, thetaMat=tMat, nStud=10, simVariability=FALSE) s &lt;-sim %&gt;% confint(c(&quot;centr&quot;, &quot;eff&quot;)) #&gt; summarizing data...done plot(s) 请注意，因为omega和sigma的实现不是模拟的， 所以$omega.list和$sigma.list都返回NULL。 11.3.3.0.1 rxode2多线程求解与仿真 rxode2现在现在支持在支持OpenMP的编译器(包括Linux和Windows)上进行多线程求解。默认情况下也可以支持Mac OSX，它使用rxCores()确定的所有可用内核进行解算。根据您的系统的不同，这可能是矫枉过正，在某个时候，求解的速度受到计算能力以外的因素的限制。 您还可以通过使用多核来使用threefry模拟引擎生成随机偏差来加快模拟速度。这由nCoresRV参数控制。例如： sim &lt;- rxSolve(mod, theta, ev, omega=omega, nSub=100, sigma=sigma, thetaMat=tMat, nStud=10, nCoresRV=2) s &lt;-sim %&gt;% confint(c(&quot;eff&quot;, &quot;centr&quot;)) #&gt; summarizing data...done 默认情况下为1核，因为结果取决于模拟中使用的核数和随机种子，以及每个线程共享/架构的工作负载。但是，如果您确保您的合作者拥有相同数量的可用内核，并且拥有支持OpenMP线程的编译，那么您可以使用更多的内核来加快此过程。 11.4使用先验数据进行求解 rxode2可以使用单一个体或 多个个体的单个事件表来求解ODEs。此外，rxode2可以使用带有个性化事件的任意数据框。例如，当使用nlmixr时，您可以使用 rxode2/vignettes/theo_sd数据框 library(rxode2) ### Load data from nlmixr d &lt;- qs::qread(&quot;rxode2/vignettes/theo_sd.qs&quot;) ### Create rxode2 model theo &lt;- rxode2({ tka ~ 0.45 # Log Ka tcl ~ 1 # Log Cl tv ~ 3.45 # Log V eta.ka ~ 0.6 eta.cl ~ 0.3 eta.v ~ 0.1 ka &lt;- exp(tka + eta.ka) cl &lt;- exp(tcl + eta.cl) v &lt;- exp(tv + eta.v) d/dt(depot) = -ka * depot d/dt(center) = ka * depot - cl / v * center cp = center / v }) ### Create parameter dataset library(dplyr) parsDf &lt;- tribble( ~ eta.ka, ~ eta.cl, ~ eta.v, 0.105, -0.487, -0.080, 0.221, 0.144, 0.021, 0.368, 0.031, 0.058, -0.277, -0.015, -0.007, -0.046, -0.155, -0.142, -0.382, 0.367, 0.203, -0.791, 0.160, 0.047, -0.181, 0.168, 0.096, 1.420, 0.042, 0.012, -0.738, -0.391, -0.170, 0.790, 0.281, 0.146, -0.527, -0.126, -0.198) %&gt;% mutate(tka = 0.451, tcl = 1.017, tv = 3.449) ### Now solve the dataset solveData &lt;- rxSolve(theo, parsDf, d) plot(solveData, cp) print(solveData) #&gt; ── Solved rxode2 object ── #&gt; ── Parameters ($params): ── #&gt; # A tibble: 12 × 1 #&gt; id #&gt; &lt;fct&gt; #&gt; 1 1 #&gt; 2 2 #&gt; 3 3 #&gt; 4 4 #&gt; 5 5 #&gt; 6 6 #&gt; 7 7 #&gt; 8 8 #&gt; 9 9 #&gt; 10 10 #&gt; 11 11 #&gt; 12 12 #&gt; ── Initial Conditions ($inits): ── #&gt; depot center #&gt; 0 0 #&gt; ── First part of data (object): ── #&gt; # A tibble: 132 × 8 #&gt; id time ka cl v cp depot center #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 0 2.86 3.67 34.8 0 320. 0 #&gt; 2 1 0.25 2.86 3.67 34.8 4.62 157. 161. #&gt; 3 1 0.57 2.86 3.67 34.8 7.12 62.8 248. #&gt; 4 1 1.12 2.86 3.67 34.8 8.09 13.0 282. #&gt; 5 1 2.02 2.86 3.67 34.8 7.68 0.996 267. #&gt; 6 1 3.82 2.86 3.67 34.8 6.38 0.00581 222. #&gt; # … with 126 more rows ### Of course the fasest way to solve if you don&#39;t care about the rxode2 extra parameters is solveData &lt;- rxSolve(theo, parsDf, d, returnType=&quot;data.frame&quot;) ### solved data dplyr::as.tbl(solveData) #&gt; # A tibble: 132 × 8 #&gt; id time ka cl v cp depot center #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 0 2.86 3.67 34.8 0 3.20E+2 0 #&gt; 2 1 0.25 2.86 3.67 34.8 4.62 1.57E+2 161. #&gt; 3 1 0.57 2.86 3.67 34.8 7.12 6.28E+1 248. #&gt; 4 1 1.12 2.86 3.67 34.8 8.09 1.30E+1 282. #&gt; 5 1 2.02 2.86 3.67 34.8 7.68 9.96E-1 267. #&gt; 6 1 3.82 2.86 3.67 34.8 6.38 5.81E-3 222. #&gt; 7 1 5.1 2.86 3.67 34.8 5.58 1.50E-4 194. #&gt; 8 1 7.03 2.86 3.67 34.8 4.55 6.02E-7 158. #&gt; 9 1 9.05 2.86 3.67 34.8 3.68 1.77E-9 128. #&gt; 10 1 12.1 2.86 3.67 34.8 2.66 9.43E-9 92.6 #&gt; # … with 122 more rows data.table::data.table(solveData) #&gt; id time ka cl v cp depot center #&gt; 1: 1 0.00 2.857651 3.669297 34.81332 0.0000000 3.199920E+02 0.00000 #&gt; 2: 1 0.25 2.857651 3.669297 34.81332 4.6240421 1.566295E+02 160.97825 #&gt; 3: 1 0.57 2.857651 3.669297 34.81332 7.1151647 6.276731E+01 247.70249 #&gt; 4: 1 1.12 2.857651 3.669297 34.81332 8.0922106 1.303613E+01 281.71670 #&gt; 5: 1 2.02 2.857651 3.669297 34.81332 7.6837844 9.958446E-01 267.49803 #&gt; --- #&gt; 128: 12 5.07 2.857651 3.669297 34.81332 5.6044213 1.636210E-04 195.10850 #&gt; 129: 12 7.07 2.857651 3.669297 34.81332 4.5392337 5.385697E-07 158.02579 #&gt; 130: 12 9.03 2.857651 3.669297 34.81332 3.6920276 1.882087E-09 128.53173 #&gt; 131: 12 12.05 2.857651 3.669297 34.81332 2.6855080 8.461424E-09 93.49144 #&gt; 132: 12 24.15 2.857651 3.669297 34.81332 0.7501667 -4.775222E-10 26.11579 "],["第十二章例子.html", "第十二章例子 12.1仅预测的模型 12.2已求解的房室模型 12.3混合已求解的系统和ODEs 12.4基于体重的给药 12.5场景间和其他嵌套示例 12.6转移室模型", " 第十二章例子 本节是一些示例模型，帮助您在常见的模拟场景中入门。 12.1仅预测的模型 仅预测模型很容易创建。您使用 rxode2 语法时没有任何 ODE 系统。一个非常简单的例子是一房室模型。 library(rxode2) mod &lt;- rxode2({ ipre &lt;- 10 * exp(-ke * t); }) mod #&gt; rxode2 2.0.11 model named rx_0e10114a74e3a755fa455546005b64e9 model (✔ ready). #&gt; x$params: ke #&gt; x$lhs: ipre 求解rxode2模型与保存简单的ODE系统相同，但当然更快。 et &lt;- et(seq(0,24,length.out=50)) cmt1 &lt;- rxSolve(mod,et,params=c(ke=0.5)) cmt1 #&gt; ── Solved rxode2 object ── #&gt; ── Parameters (x$params): ── #&gt; ke #&gt; 0.5 #&gt; ── Initial Conditions (x$inits): ── #&gt; named numeric(0) #&gt; ── First part of data (object): ── #&gt; # A tibble: 50 × 2 #&gt; time ipre #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 10 #&gt; 2 0.490 7.83 #&gt; 3 0.980 6.13 #&gt; 4 1.47 4.80 #&gt; 5 1.96 3.75 #&gt; 6 2.45 2.94 #&gt; # … with 44 more rows 12.2已求解的房室模型 已求解的模型也很容易创建。您只需将 linCmt()伪函数到您的代码中。linCmt()函数根据参数名称找出要使用的模型类型。 定量药理学模型通常使用清除率的参数化（主要即主要以清除率和表观分布容积参数描述房室模型）。清除率参数化的房室也存在多种实现形式，比如由NONMEM风格的名称 CL、Q、Q1、Q2等指定，或由分布清除率CLD， CLD2指定。分布容积由Central（VC或V）指定， 外周/组织（VP，VT）。虽然还有更多的清除率参数化方式的名称命名方式可用，但下面是一些清除率参数化方式的参数名称命名方式的示例： par1 par2 par3 par4 par5 par6 par7 ncmt ka cl q q2 v vp vp2 3 cl q q2 v vp vp2 3 ka cl q q2 vc vp vp2 3 cl q q2 vc vp vp2 3 ka cl q1 q2 v vp vp2 3 另一个种流行的参数化方式是微观参数化方式。rxode2 假设1号房室是中央室，消除速率常数由K、Ke或Kel指定。下面一些微观参数化方式的参数名称命名方式的示例： par1 par2 par3 par4 par5 par6 par7 ncmt ka v k k12 k21 k13 k31 3 v k k12 k21 k13 k31 3 ka vc k 12 k21 k13 k31 3 vc k k12 k21 k13 k31 3 ka v1 k 12 k21 k13 k31 3 最后一个可能用到的参数化方式是是使用alpha和V和/或 A/B/C等参数进行参数化，即宏观参数化方式。下面一些宏观参数化方式的参数名称命名方式的示例： par1 par2 par3 par4 par5 par6 par7 ncmt ka v alpha beta aob 1 v alpha beta aob 1 ka vc alpha beta aob 1 vc alpha beta aob 1 ka v1 alpha beta aob 1 一旦linCmt()完成侦测，1、2或3 房室模型的解析将作为linCmt()的值。 当模型中存在一级速率吸收常数 ka 时，可以在线性已求解系统中进行给药的房室是 depot和central。在没有任何额外的ODE的情况下，这些房室的编号是depot=1及central=2。 当缺少一级速率吸收常数 ka 时，你仅可以向 central房室给药。在没有任何额外的ODE的情况下，这些房室的编号是central=1。 这些房室采用与ODE模型相同的事件类型，并在rxode2事件插图中讨论。 mod &lt;- rxode2({ ke &lt;- 0.5 V &lt;- 1 ipre &lt;- linCmt(); }) mod #&gt; rxode2 2.0.11 model named rx_c0a8cbd1096a07a0112eacf07071569f model (✔ ready). #&gt; x$stateExtra: central #&gt; x$params: ke, V #&gt; x$lhs: ipre 然后它将充当ODE模型;您可以在指定一次给药至depot房室事件后，求解这个系统： et &lt;- et(amt=10,time=0,cmt=depot) %&gt;% et(seq(0,24,length.out=50)) cmt1 &lt;- rxSolve(mod,et,params=c(ke=0.5)) cmt1 #&gt; ── Solved rxode2 object ── #&gt; ── Parameters (x$params): ── #&gt; ke V #&gt; 0.5 1.0 #&gt; ── Initial Conditions (x$inits): ── #&gt; named numeric(0) #&gt; ── First part of data (object): ── #&gt; # A tibble: 50 × 2 #&gt; time ipre #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 10 #&gt; 2 0.490 7.83 #&gt; 3 0.980 6.13 #&gt; 4 1.47 4.80 #&gt; 5 1.96 3.75 #&gt; 6 2.45 2.94 #&gt; # … with 44 more rows 12.3混合已求解的系统和ODEs 除了纯ODE之外，您还可以将已求解的系统与ODE混合。先前的2房室间接效应模型可以简化为一个 linCmt()函数： library(rxode2) ## Setup example model mod1 &lt;-rxode2({ C2 = centr/V2; C3 = peri/V3; d/dt(depot) =-KA*depot; d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; }); ## Seup parameters and initial conditions theta &lt;- c(KA=2.94E-01, CL=1.86E+01, V2=4.02E+01, # central Q=1.05E+01, V3=2.97E+02, # peripheral Kin=1, Kout=1, EC50=200) # effects inits &lt;- c(eff=1); ## Setup dosing event information ev &lt;- eventTable(amount.units=&quot;mg&quot;, time.units=&quot;hours&quot;) %&gt;% add.dosing(dose=10000, nbr.doses=10, dosing.interval=12) %&gt;% add.dosing(dose=20000, nbr.doses=5, start.time=120,dosing.interval=24) %&gt;% add.sampling(0:240); ## Setup a mixed solved/ode system: mod2 &lt;- rxode2({ ## the order of variables do not matter, the type of compartmental ## model is determined by the parameters specified. C2 = linCmt(KA, CL, V2, Q, V3); eff(0) = 1 ## This specifies that the effect compartment starts at 1. d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; }) 这允许上面的间接反应模型将2房室模型分配给C2变量，并在间接效应模型中使用。 当混合已求解的系统和ODEs时，已求解系统的房室总是最后一个房室。这是因为已求解的系统在技术上不是待解决的房室。在最后添加给药房室末端不会干扰需要求解的实际ODE。 因此，在2房室间接效应模型中，效应室eff是#1房室，而PK给药的房室depot房室是#2号房室。 此房室模型需要一个新的事件表，因为房室编号已更改： ev &lt;- eventTable(amount.units=&#39;mg&#39;, time.units=&#39;hours&#39;) %&gt;% add.dosing(dose=10000, nbr.doses=10, dosing.interval=12,dosing.to=2) %&gt;% add.dosing(dose=20000, nbr.doses=5, start.time=120,dosing.interval=24,dosing.to=2) %&gt;% add.sampling(0:240); 这可以通过以下命令求解： x &lt;- mod2 %&gt;% solve(theta, ev) print(x) #&gt; ── Solved rxode2 object ── #&gt; ── Parameters ($params): ── #&gt; CL V2 Q V3 KA Kin Kout EC50 #&gt; 18.600 40.200 10.500 297.000 0.294 1.000 1.000 200.000 #&gt; ── Initial Conditions ($inits): ── #&gt; eff #&gt; 1 #&gt; ── First part of data (object): ── #&gt; # A tibble: 241 × 3 #&gt; time C2 eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 249. 1 #&gt; 2 1 121. 1.35 #&gt; 3 2 60.3 1.38 #&gt; 4 3 31.0 1.28 #&gt; 5 4 17.0 1.18 #&gt; 6 5 10.2 1.11 #&gt; # … with 235 more rows 请注意，此求解不需要指定效应室eff初始条件为1。相反，此初始条件已经由eff(0)=1预先指定。 这可以轻松的实现对不同的初始条件的求解： x &lt;- mod2 %&gt;% solve(theta, ev,c(eff=2)) print(x) #&gt; ── Solved rxode2 object ── #&gt; ── Parameters ($params): ── #&gt; CL V2 Q V3 KA Kin Kout EC50 #&gt; 18.600 40.200 10.500 297.000 0.294 1.000 1.000 200.000 #&gt; ── Initial Conditions ($inits): ── #&gt; eff #&gt; 2 #&gt; ── First part of data (object): ── #&gt; # A tibble: 241 × 3 #&gt; time C2 eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 249. 2 #&gt; 2 1 121. 1.93 #&gt; 3 2 60.3 1.67 #&gt; 4 3 31.0 1.41 #&gt; 5 4 17.0 1.23 #&gt; 6 5 10.2 1.13 #&gt; # … with 235 more rows 如果您已经在块中定义了变量，则rxode2侦测也不需要您在linCmt()函数中再次进行指定。因此，下面的函数也将解决同一个系统。 mod3 &lt;- rxode2({ KA=2.94E-01; CL=1.86E+01; V2=4.02E+01; Q=1.05E+01; V3=2.97E+02; Kin=1; Kout=1; EC50=200; ## The linCmt() picks up the variables from above C2 = linCmt(); eff(0) = 1 ## This specifies that the effect compartment starts at 1. d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; }) x &lt;- mod3 %&gt;% solve(ev) print(x) #&gt; ── Solved rxode2 object ── #&gt; ── Parameters ($params): ── #&gt; KA CL V2 Q V3 Kin Kout EC50 #&gt; 0.294 18.600 40.200 10.500 297.000 1.000 1.000 200.000 #&gt; ── Initial Conditions ($inits): ── #&gt; eff #&gt; 1 #&gt; ── First part of data (object): ── #&gt; # A tibble: 241 × 3 #&gt; time C2 eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 249. 1 #&gt; 2 1 121. 1.35 #&gt; 3 2 60.3 1.38 #&gt; 4 3 31.0 1.28 #&gt; 5 4 17.0 1.18 #&gt; 6 5 10.2 1.11 #&gt; # … with 235 more rows 请注意，您在求解上述模型系统时不需要指定参数，因为它们已经内置在模型中，但您可以覆盖参数： x &lt;- mod3 %&gt;% solve(c(KA=10),ev) print(x) #&gt; ── Solved rxode2 object ── #&gt; ── Parameters ($params): ── #&gt; KA CL V2 Q V3 Kin Kout EC50 #&gt; 10.0 18.6 40.2 10.5 297.0 1.0 1.0 200.0 #&gt; ── Initial Conditions ($inits): ── #&gt; eff #&gt; 1 #&gt; ── First part of data (object): ── #&gt; # A tibble: 241 × 3 #&gt; time C2 eff #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 249. 1 #&gt; 2 1 121. 1.35 #&gt; 3 2 60.3 1.38 #&gt; 4 3 31.0 1.28 #&gt; 5 4 17.0 1.18 #&gt; 6 5 10.2 1.11 #&gt; # … with 235 more rows 12.4基于体重的给药 这是一个达托霉素(daptomycin)基于重量给药的示例模型。达托霉素(daptomycin)是一种来自发酵的玫瑰孢链霉菌(roseosporus)的环状脂肽抗生素。 基于体重的给药模拟有3个阶段：-1.创建rxode2模型 -2. 模拟协变量 -3.创建基于体重的给药的事件表（与协变量合并） 12.4.1在rxode2中创建2房室模型 library(rxode2) ## Note the time covariate is not included in the simulation m1 &lt;- rxode2({ CL ~ (1-0.2*SEX)*(0.807+0.00514*(CRCL-91.2))*exp(eta.cl) V1 ~ 4.8*exp(eta.v1) Q ~ (3.46+0.0593*(WT-75.1))*exp(eta.q); V2 ~ 1.93*(3.13+0.0458*(WT-75.1))*exp(eta.v2) A1 ~ centr; A2 ~ peri; d/dt(centr) ~ - A1*(CL/V1 + Q/V1) + A2*Q/V2; d/dt(peri) ~ A1*Q/V1 - A2*Q/V2; DV = centr / V1 * (1 + prop.err) }) 12.4.2模拟协变量 此模拟与年龄、性别和体重相关。由于我们将使用基于体重的给药，因此需要首先对协变量进行模拟 set.seed(42) rxSetSeed(42) library(dplyr) nsub=30 ### Simulate Weight based on age and gender AGE&lt;-round(runif(nsub,min=18,max=70)) SEX&lt;-round(runif(nsub,min=0,max=1)) HTm&lt;-round(rnorm(nsub,176.3,0.17*sqrt(4482)),digits=1) HTf&lt;-round(rnorm(nsub,162.2,0.16*sqrt(4857)),digits=1) WTm&lt;-round(exp(3.28+1.92*log(HTm/100))*exp(rnorm(nsub,0,0.14)),digits=1) WTf&lt;-round(exp(3.49+1.45*log(HTf/100))*exp(rnorm(nsub,0,0.17)),digits=1) WT&lt;-ifelse(SEX==1,WTf,WTm) CRCL&lt;-round(runif(nsub,30,140)) ## id is in lower case to match the event table cov.df &lt;- tibble(id=seq_along(AGE), AGE=AGE, SEX=SEX, WT=WT, CRCL=CRCL) print(cov.df) #&gt; # A tibble: 30 x 5 #&gt; id AGE SEX WT CRCL #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 66 1 49.4 83 #&gt; 2 2 67 1 52.5 79 #&gt; 3 3 33 0 97.9 37 #&gt; 4 4 61 1 63.8 66 #&gt; 5 5 51 0 71.8 127 #&gt; 6 6 45 1 69.6 132 #&gt; 7 7 56 0 61 73 #&gt; 8 8 25 0 57.7 47 #&gt; 9 9 52 1 58.7 65 #&gt; 10 10 55 1 73.1 64 #&gt; # ... with 20 more rows 12.4.3创建基于体重的事件表 s&lt;-c(0,0.25,0.5,0.75,1,1.5,seq(2,24,by=1)) s &lt;- lapply(s, function(x){.x &lt;- 0.1 * x; c(x - .x, x + .x)}) e &lt;- et() %&gt;% ## Specify the id and weight based dosing from covariate data.frame ## This requires rxode2 XXX et(id=cov.df$id, amt=6*cov.df$WT, rate=6 * cov.df$WT) %&gt;% ## Sampling is added for each ID et(s) %&gt;% as.data.frame %&gt;% ## Merge the event table with the covarite information merge(cov.df, by=&quot;id&quot;) %&gt;% as_tibble e #&gt; # A tibble: 900 x 12 #&gt; id low time high cmt amt rate evid AGE SEX WT CRCL #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 0 0 0 (obs) NA NA 0 66 1 49.4 83 #&gt; 2 1 NA 0 NA (default) 296. 296. 1 66 1 49.4 83 #&gt; 3 1 0.225 0.246 0.275 (obs) NA NA 0 66 1 49.4 83 #&gt; 4 1 0.45 0.516 0.55 (obs) NA NA 0 66 1 49.4 83 #&gt; 5 1 0.675 0.729 0.825 (obs) NA NA 0 66 1 49.4 83 #&gt; 6 1 0.9 0.921 1.1 (obs) NA NA 0 66 1 49.4 83 #&gt; 7 1 1.35 1.42 1.65 (obs) NA NA 0 66 1 49.4 83 #&gt; 8 1 1.8 1.82 2.2 (obs) NA NA 0 66 1 49.4 83 #&gt; 9 1 2.7 2.97 3.3 (obs) NA NA 0 66 1 49.4 83 #&gt; 10 1 3.6 3.87 4.4 (obs) NA NA 0 66 1 49.4 83 #&gt; # ... with 890 more rows 12.4.4求解达托霉素的模拟 data &lt;- rxSolve(m1, e, ## Lotri uses lower-triangular matrix rep. for named matrix omega=lotri(eta.cl ~ .306, eta.q ~0.0652, eta.v1 ~.567, eta.v2 ~ .191), sigma=lotri(prop.err ~ 0.15), addDosing = TRUE, addCov = TRUE) print(data) #&gt; -- Solved rxode2 object -- #&gt; -- Parameters ($params): -- #&gt; # A tibble: 30 x 5 #&gt; id eta.cl eta.v1 eta.q eta.v2 #&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 -0.147 0.112 0.284 -0.187 #&gt; 2 2 -0.280 -0.189 0.222 -0.843 #&gt; 3 3 0.515 0.471 0.0387 -0.687 #&gt; 4 4 -0.359 0.351 0.269 0.146 #&gt; 5 5 0.565 -0.240 0.363 0.330 #&gt; 6 6 -0.991 1.95 0.0108 -0.352 #&gt; 7 7 -0.604 -1.19 0.0556 0.0760 #&gt; 8 8 -0.500 -0.212 0.315 0.902 #&gt; 9 9 1.33 0.317 -0.0113 0.164 #&gt; 10 10 0.201 0.390 0.182 -0.277 #&gt; # ... with 20 more rows #&gt; -- Initial Conditions ($inits): -- #&gt; centr peri #&gt; 0 0 #&gt; -- First part of data (object): -- #&gt; # A tibble: 900 x 9 #&gt; id evid cmt amt time DV SEX WT CRCL #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 1 296. 0 0 1 49.4 83 #&gt; 2 1 0 NA NA 0 0 1 49.4 83 #&gt; 3 1 0 NA NA 0.246 7.72 1 49.4 83 #&gt; 4 1 0 NA NA 0.516 21.2 1 49.4 83 #&gt; 5 1 0 NA NA 0.729 27.4 1 49.4 83 #&gt; 6 1 0 NA NA 0.921 39.1 1 49.4 83 #&gt; # ... with 894 more rows plot(data, log=&quot;y&quot;) #&gt; Warning in self$trans$transform(x): NaNs produced #&gt; Warning: Transformation introduced infinite values in continuous y-axis #&gt; Warning: Removed 1 row containing missing values (`geom_line()`). 12.4.5达托霉素的参考文献 这种基于重量的模拟改编自下面的关于达托霉素的文献： Dvorchik B, Arbeit RD, Chung J, Liu S, Knebel W, Kastrissios H..达托霉素的群体药代动力学. Antimicrob Agents Che mother 2004; 48: 2799-2807. doi:(10.1128/AAC.48.8.2799-2807.2004[https://dx.doi.org/10.1128%2FAAC.48.8.2799-2807.2004] 此模拟示例来自Sherwin Sy的创作，并由Matthew Fidler进行了修改 12.5场景间和其他嵌套示例 在rxode2中可以进行多个级别的嵌套;在此示例中，我们将使用以下不确定性和可变性来源： 水平 变量 矩阵指定 集成矩阵 模型不确定性 NA thetaMat thetaMat 研究者间 inv.Cl，inv.Ka omega theta 个体间 eta.Cl，eta.Ka omega omega 眼睛 eye.Cl，eye.Ka omega omega 场景间 iov.Cl，occ.Ka omega omega 浓度的无法解释变异 prop.sd sigma sigma 效应的无法解释变异 add.sd sigma sigma 12.5.1事件表 此事件表包含嵌套变量： inv：研究者ID【译者注：这里应该是想要表达临床试验不同研究中心间的变异，研究中心有时被抽象为site:中心，此处作者抽象为investigator:研究者】 id：个体id 眼睛：眼睛ID（左或右） occ：场景 library(rxode2) library(dplyr) et(amountUnits=&quot;mg&quot;, timeUnits=&quot;hours&quot;) %&gt;% et(amt=10000, addl=9,ii=12,cmt=&quot;depot&quot;) %&gt;% et(time=120, amt=2000, addl=4, ii=14, cmt=&quot;depot&quot;) %&gt;% et(seq(0, 240, by=4)) %&gt;% # Assumes sampling when there is no dosing information et(seq(0, 240, by=4) + 0.1) %&gt;% ## adds 0.1 for separate eye et(id=1:20) %&gt;% ## Add an occasion per dose mutate(occ=cumsum(!is.na(amt))) %&gt;% mutate(occ=ifelse(occ == 0, 1, occ)) %&gt;% mutate(occ=2- occ %% 2) %&gt;% mutate(eye=ifelse(round(time) == time, 1, 2)) %&gt;% mutate(inv=ifelse(id &lt; 10, 1, 2)) %&gt;% as_tibble -&gt; ev 12.5.2rxode2模型 这将创建具有多级嵌套的rxode2模型。注意变量inv.Cl，inv.Ka，eta.Cl等;每一个嵌套层级只需要一个变量。 mod &lt;- rxode2({ ## Clearance with individuals eff(0) = 1 C2 = centr/V2*(1+prop.sd); C3 = peri/V3; CL = TCl*exp(eta.Cl + eye.Cl + iov.Cl + inv.Cl) KA = TKA * exp(eta.Ka + eye.Ka + iov.Cl + inv.Ka) d/dt(depot) =-KA*depot; d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; ef0 = eff + add.sd }) 12.5.3模型参数的不确定性 theta &lt;- c(&quot;TKA&quot;=0.294, &quot;TCl&quot;=18.6, &quot;V2&quot;=40.2, &quot;Q&quot;=10.5, &quot;V3&quot;=297, &quot;Kin&quot;=1, &quot;Kout&quot;=1, &quot;EC50&quot;=200) ## Creating covariance matrix tmp &lt;- matrix(rnorm(8^2), 8, 8) tMat &lt;- tcrossprod(tmp, tmp) / (8 ^ 2) dimnames(tMat) &lt;- list(names(theta), names(theta)) tMat #&gt; TKA TCl V2 Q V3 #&gt; TKA 1.408151E-01 0.08277499 0.0180178917 -0.0470325576 0.029172564 #&gt; TCl 8.277499E-02 0.18104452 -0.0532724661 -0.0421074920 0.068093695 #&gt; V2 1.801789E-02 -0.05327247 0.0581816756 0.0001167516 0.006496495 #&gt; Q -4.703256E-02 -0.04210749 0.0001167516 0.1549374667 0.020764042 #&gt; V3 2.917256E-02 0.06809370 0.0064964951 0.0207640421 0.118986685 #&gt; Kin -3.445136E-02 0.01464937 -0.0426405263 0.1503174753 -0.039702872 #&gt; Kout -2.904363E-02 -0.04914350 0.0324790929 0.0069332072 0.030349396 #&gt; EC50 -4.017336E-05 0.02850637 -0.0326094799 -0.0489119232 -0.029606732 #&gt; Kin Kout EC50 #&gt; TKA -0.034451357 -0.029043632 -4.017336E-05 #&gt; TCl 0.014649373 -0.049143503 2.850637E-02 #&gt; V2 -0.042640526 0.032479093 -3.260948E-02 #&gt; Q 0.150317475 0.006933207 -4.891192E-02 #&gt; V3 -0.039702872 0.030349396 -2.960673E-02 #&gt; Kin 0.299597107 -0.074421154 -6.528526E-03 #&gt; Kout -0.074421154 0.061039604 -2.800741E-02 #&gt; EC50 -0.006528526 -0.028007407 4.167429E-02 12.5.4嵌套变异性 要指定多级嵌套，您可以将其指定为嵌套的 lotri矩阵;使用这种方法时，您使用条件运算符|指定在哪个变量上发生嵌套;对于贝叶斯模拟，我们需要指定每个参数有多少信息;对于rxode2，这是nu参数。 在这种情况下： -id，nu=100或模型来自100个受试者， -eye，nu=200或模型来自200只眼睛 ，-occ，nu=200或模型来自200种场景，-inv，nu=10或模型来自10名研究者 要在lotri指定，可以使用| var(nu=X)，或者： omega &lt;- lotri(lotri(eta.Cl ~ 0.1, eta.Ka ~ 0.1) | id(nu=100), lotri(eye.Cl ~ 0.05, eye.Ka ~ 0.05) | eye(nu=200), lotri(iov.Cl ~ 0.01, iov.Ka ~ 0.01) | occ(nu=200), lotri(inv.Cl ~ 0.02, inv.Ka ~ 0.02) | inv(nu=10)) omega #&gt; $id #&gt; eta.Cl eta.Ka #&gt; eta.Cl 0.1 0.0 #&gt; eta.Ka 0.0 0.1 #&gt; #&gt; $eye #&gt; eye.Cl eye.Ka #&gt; eye.Cl 0.05 0.00 #&gt; eye.Ka 0.00 0.05 #&gt; #&gt; $occ #&gt; iov.Cl iov.Ka #&gt; iov.Cl 0.01 0.00 #&gt; iov.Ka 0.00 0.01 #&gt; #&gt; $inv #&gt; inv.Cl inv.Ka #&gt; inv.Cl 0.02 0.00 #&gt; inv.Ka 0.00 0.02 #&gt; #&gt; Properties: nu 12.5.5无法解释的变异 最后要指定的可变性是无法解释的变异 sigma &lt;- lotri(prop.sd ~ .25, add.sd~ 0.125) 12.5.6求解问题 s &lt;- rxSolve(mod, theta, ev, thetaMat=tMat, omega=omega, sigma=sigma, sigmaDf=400, nStud=400) #&gt; unhandled error message: EE:[lsoda] 70000 steps taken before reaching tout #&gt; @(lsoda.c:750 #&gt; Warning: some ID(s) could not solve the ODEs correctly; These values are #&gt; replaced with &#39;NA&#39; print(s) #&gt; -- Solved rxode2 object -- #&gt; -- Parameters ($params): -- #&gt; # A tibble: 8,000 x 24 #&gt; sim.id id inv.Cl~1 inv.C~2 inv.K~3 inv.K~4 eye.C~5 eye.C~6 eye.K~7 eye.K~8 #&gt; &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 -0.202 0.314 -0.260 0.170 0.171 -0.420 -0.140 -0.472 #&gt; 2 1 2 -0.202 0.314 -0.260 0.170 0.0361 0.0354 0.0821 -0.418 #&gt; 3 1 3 -0.202 0.314 -0.260 0.170 0.269 0.0473 -0.484 -0.101 #&gt; 4 1 4 -0.202 0.314 -0.260 0.170 -0.231 -0.180 -0.131 0.0724 #&gt; 5 1 5 -0.202 0.314 -0.260 0.170 -0.368 0.129 0.501 0.172 #&gt; 6 1 6 -0.202 0.314 -0.260 0.170 -0.113 -0.208 -0.590 -0.334 #&gt; 7 1 7 -0.202 0.314 -0.260 0.170 -0.276 0.117 -0.254 -0.148 #&gt; 8 1 8 -0.202 0.314 -0.260 0.170 0.231 -0.0689 0.129 0.507 #&gt; 9 1 9 -0.202 0.314 -0.260 0.170 -0.292 -0.344 0.107 0.232 #&gt; 10 1 10 -0.202 0.314 -0.260 0.170 -0.293 0.0939 -0.514 -0.185 #&gt; # ... with 7,990 more rows, 14 more variables: `iov.Cl(occ==1)` &lt;dbl&gt;, #&gt; # `iov.Cl(occ==2)` &lt;dbl&gt;, `iov.Ka(occ==1)` &lt;dbl&gt;, `iov.Ka(occ==2)` &lt;dbl&gt;, #&gt; # V2 &lt;dbl&gt;, V3 &lt;dbl&gt;, TCl &lt;dbl&gt;, eta.Cl &lt;dbl&gt;, TKA &lt;dbl&gt;, eta.Ka &lt;dbl&gt;, #&gt; # Q &lt;dbl&gt;, Kin &lt;dbl&gt;, Kout &lt;dbl&gt;, EC50 &lt;dbl&gt;, and abbreviated variable names #&gt; # 1: `inv.Cl(inv==1)`, 2: `inv.Cl(inv==2)`, 3: `inv.Ka(inv==1)`, #&gt; # 4: `inv.Ka(inv==2)`, 5: `eye.Cl(eye==1)`, 6: `eye.Cl(eye==2)`, #&gt; # 7: `eye.Ka(eye==1)`, 8: `eye.Ka(eye==2)` #&gt; -- Initial Conditions ($inits): -- #&gt; depot centr peri eff #&gt; 0 0 0 1 #&gt; #&gt; Simulation with uncertainty in: #&gt; * parameters ($thetaMat for changes) #&gt; * omega matrix ($omegaList) #&gt; #&gt; -- First part of data (object): -- #&gt; # A tibble: 976,000 x 21 #&gt; sim.id id time inv.Cl inv.Ka eye.Cl eye.Ka iov.Cl iov.Ka C2 C3 #&gt; &lt;int&gt; &lt;int&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 0 -0.202 -0.260 0.171 -0.140 -0.0381 0.0391 0 0 #&gt; 2 1 1 0.1 -0.202 -0.260 -0.420 -0.472 -0.0381 0.0391 -2.95 -0.00314 #&gt; 3 1 1 4 -0.202 -0.260 0.171 -0.140 -0.0381 0.0391 -53.9 -2.18 #&gt; 4 1 1 4.1 -0.202 -0.260 -0.420 -0.472 -0.0381 0.0391 -36.2 -2.27 #&gt; 5 1 1 8 -0.202 -0.260 0.171 -0.140 -0.0381 0.0391 -58.0 -6.11 #&gt; 6 1 1 8.1 -0.202 -0.260 -0.420 -0.472 -0.0381 0.0391 -22.8 -6.22 #&gt; # ... with 975,994 more rows, and 10 more variables: CL &lt;dbl&gt;, KA &lt;dbl&gt;, #&gt; # ef0 &lt;dbl&gt;, depot &lt;dbl&gt;, centr &lt;dbl&gt;, peri &lt;dbl&gt;, eff &lt;dbl&gt;, occ &lt;fct&gt;, #&gt; # eye &lt;fct&gt;, inv &lt;fct&gt; 一项研究中有多名研究者;每个研究者都有一些受试者在他的研究中心入组.rxode2自动确定研究者的数量，然后在研究者水平为每个研究者模拟随机效应。对于输出，inv.Cl(inv==1)将输出研究者1的inv.Cl，inv.Cl(inv==2)将输出研究者2的inv.Cl等。 inv.Cl(inv==1)、inv.Cl(inv==2)等将在每个研究中被模拟，然后合并以形成研究者之间的变异。在方程形式中，它们表示如下： inv.Cl = (inv == 1) * `inv.Cl(inv==1)` + (inv == 2) * `inv.Cl(inv==2)` 如果您查看模拟的参数，您可以看到inv.Cl(inv==1) 和inv.Cl(inv==2)都在s$params中;它在每个研究中是相同的： print(head(s$params)) #&gt; sim.id id inv.Cl(inv==1) inv.Cl(inv==2) inv.Ka(inv==1) inv.Ka(inv==2) #&gt; 1 1 1 -0.2022386 0.3144136 -0.2599115 0.1699445 #&gt; 2 1 2 -0.2022386 0.3144136 -0.2599115 0.1699445 #&gt; 3 1 3 -0.2022386 0.3144136 -0.2599115 0.1699445 #&gt; 4 1 4 -0.2022386 0.3144136 -0.2599115 0.1699445 #&gt; 5 1 5 -0.2022386 0.3144136 -0.2599115 0.1699445 #&gt; 6 1 6 -0.2022386 0.3144136 -0.2599115 0.1699445 #&gt; eye.Cl(eye==1) eye.Cl(eye==2) eye.Ka(eye==1) eye.Ka(eye==2) iov.Cl(occ==1) #&gt; 1 0.17073129 -0.41996232 -0.1396676 -0.47194363 -0.038088093 #&gt; 2 0.03607197 0.03541692 0.0821007 -0.41780285 -0.137537040 #&gt; 3 0.26936860 0.04732331 -0.4842336 -0.10113442 0.051341682 #&gt; 4 -0.23101553 -0.17967167 -0.1311976 0.07238211 0.083307828 #&gt; 5 -0.36771204 0.12904386 0.5007750 0.17169021 -0.006988387 #&gt; 6 -0.11255970 -0.20831770 -0.5903606 -0.33404416 0.017359073 #&gt; iov.Cl(occ==2) iov.Ka(occ==1) iov.Ka(occ==2) V2 V3 TCl #&gt; 1 -0.02640295 0.03906335 0.08082907 40.30657 297.0657 17.98116 #&gt; 2 0.11320643 -0.05818325 -0.04738385 40.30657 297.0657 17.98116 #&gt; 3 -0.09714493 0.11129638 -0.08423628 40.30657 297.0657 17.98116 #&gt; 4 -0.16483538 0.02682606 0.05338649 40.30657 297.0657 17.98116 #&gt; 5 -0.14905541 -0.12916147 0.15052921 40.30657 297.0657 17.98116 #&gt; 6 -0.06090189 -0.03821761 0.22133375 40.30657 297.0657 17.98116 #&gt; eta.Cl TKA eta.Ka Q Kin Kout EC50 #&gt; 1 0.1255527 -0.201923 -0.5537485 10.27033 0.3588164 1.273849 200.1076 #&gt; 2 -0.4939314 -0.201923 0.1843165 10.27033 0.3588164 1.273849 200.1076 #&gt; 3 0.3628319 -0.201923 -0.1429071 10.27033 0.3588164 1.273849 200.1076 #&gt; 4 0.9051354 -0.201923 0.3662940 10.27033 0.3588164 1.273849 200.1076 #&gt; 5 0.6288535 -0.201923 -0.0873943 10.27033 0.3588164 1.273849 200.1076 #&gt; 6 0.2794271 -0.201923 0.3369920 10.27033 0.3588164 1.273849 200.1076 print(head(s$params %&gt;% filter(sim.id == 2))) #&gt; sim.id id inv.Cl(inv==1) inv.Cl(inv==2) inv.Ka(inv==1) inv.Ka(inv==2) #&gt; 1 2 1 0.269099 -0.03113882 -0.2495935 -0.07401625 #&gt; 2 2 2 0.269099 -0.03113882 -0.2495935 -0.07401625 #&gt; 3 2 3 0.269099 -0.03113882 -0.2495935 -0.07401625 #&gt; 4 2 4 0.269099 -0.03113882 -0.2495935 -0.07401625 #&gt; 5 2 5 0.269099 -0.03113882 -0.2495935 -0.07401625 #&gt; 6 2 6 0.269099 -0.03113882 -0.2495935 -0.07401625 #&gt; eye.Cl(eye==1) eye.Cl(eye==2) eye.Ka(eye==1) eye.Ka(eye==2) iov.Cl(occ==1) #&gt; 1 0.1241993 0.041788101 0.046696060 -0.4757259 -0.12703256 #&gt; 2 -0.2429869 -0.272713695 0.535736941 -0.2558208 -0.07818270 #&gt; 3 -0.2394184 -0.191109523 -0.008623256 0.2089974 -0.10398049 #&gt; 4 -0.1136205 0.009124802 -0.061481545 0.1693383 0.28689686 #&gt; 5 -0.0571466 0.079101905 0.020527524 -0.3797383 -0.08602325 #&gt; 6 0.3404940 0.181620316 -0.230666768 -0.2565292 -0.06364471 #&gt; iov.Cl(occ==2) iov.Ka(occ==1) iov.Ka(occ==2) V2 V3 TCl #&gt; 1 0.03439817 0.013110729 0.05902598 40.11784 296.8096 18.42138 #&gt; 2 0.12976537 0.097348229 0.01634439 40.11784 296.8096 18.42138 #&gt; 3 -0.02100928 0.064078040 -0.12742109 40.11784 296.8096 18.42138 #&gt; 4 0.02594699 -0.095784927 0.25669770 40.11784 296.8096 18.42138 #&gt; 5 0.04611064 0.123204785 0.02336934 40.11784 296.8096 18.42138 #&gt; 6 -0.03241107 -0.005876249 0.13239904 40.11784 296.8096 18.42138 #&gt; eta.Cl TKA eta.Ka Q Kin Kout EC50 #&gt; 1 0.41059476 0.1568122 0.21051066 10.97538 1.775872 0.8755069 200.0143 #&gt; 2 0.12890626 0.1568122 -0.20523053 10.97538 1.775872 0.8755069 200.0143 #&gt; 3 -0.03656252 0.1568122 0.01471664 10.97538 1.775872 0.8755069 200.0143 #&gt; 4 -0.18554527 0.1568122 -0.62093051 10.97538 1.775872 0.8755069 200.0143 #&gt; 5 -0.04484490 0.1568122 -0.06739060 10.97538 1.775872 0.8755069 200.0143 #&gt; 6 0.48614515 0.1568122 -0.35082813 10.97538 1.775872 0.8755069 200.0143 对于眼睛之间和场合之间的变异性，每个人都模拟了许多变量，这些变量成为眼睛之间和场合之间的变异性;在眼睛的情况下： eye.Cl = (eye == 1) * `eye.Cl(eye==1)` + (eye == 2) * `eye.Cl(eye==2)` 因此，当您查看模拟时，这些变量中的每一个（即 eye.Cl(eye==1)、eye.Cl(eye==2)等）会随每个个体的不同而变化，当组合在一起时，会产生在某些定量药理学模型参数中可以看到的眼睛之间的变异或场景之间的变异。 12.6转移室模型 Savic 2008首次引入了转移室的概念，作为对滞后时间类型现象的机制性解释。rxode2对这类模型进行了特殊处理： 您可以以与原始论文类似的方式指定它： library(rxode2) mod &lt;- rxode2({ ## Table 3 from Savic 2007 cl = 17.2 # (L/hr) vc = 45.1 # L ka = 0.38 # 1/hr mtt = 0.37 # hr bio=1 n = 20.1 k = cl/vc ktr = (n+1)/mtt ## note that lgammafn is the same as lgamma in R. d/dt(depot) = exp(log(bio*podo(depot))+log(ktr)+n*log(ktr*tad(depot))- ktr*tad(depot)-lgammafn(n+1))-ka*depot d/dt(cen) = ka*depot-k*cen }) et &lt;- eventTable() et$add.sampling(seq(0, 7, length.out=200)) et$add.dosing(20, start.time=0, evid=7) transit &lt;- rxSolve(mod, et) plot(transit, cen, ylab=&quot;Central Concentration&quot;) 另一种选择是指定转移室函数 transit语句。这指定了参数transit(转移室数量,平均转移时间, 生物利用度)。其中生物利用度这项参数是可选的。 与前文相同的模型可以通过以下方式指定： mod &lt;- rxode2({ ## Table 3 from Savic 2007 cl = 17.2 # (L/hr) vc = 45.1 # L ka = 0.38 # 1/hr mtt = 0.37 # hr bio=1 n = 20.1 k = cl/vc ktr = (n+1)/mtt d/dt(depot) = transit(n,mtt,bio)-ka*depot d/dt(cen) = ka*depot-k*cen }) et &lt;- eventTable(); et$add.sampling(seq(0, 7, length.out=200)); et$add.dosing(20, start.time=0, evid=7); transit &lt;- rxSolve(mod, et) plot(transit, cen, ylab=&quot;Central Concentration&quot;) 使用这种方法时要记住以下几件事： 这种方法隐含地假设通过转移室的吸收在下一次给药开始之前完成 不同类型的给药房方式（即 注入/输注【译者注：比如静脉注射或静脉输液】）给药到房室，会影响到给药后时间（tad，Time After Dose）的计算 ，给药后时间会用于转移室计算，因此这又会进一步的影响转移室的计算。这些（因此）目前不受支持。最稳定的方式是使用tad(cmt)和 podo(cmt)，这样，给药到其他房室不会影响到转移室的计算。 在内部，transit语法使用当前定义的cmtd/dt(cmt)=transit(...)，或cmt。如果转移室在d/dt()之外使用（不推荐），则转移室会使用模型定义的最后一个d/dt(cmt)语句中的cmt。这也意味着房室之间不会相互影响（一种口服的，转移室药物立即静脉输注【译者注：不要怀疑你看不懂这句话，因为我也看不懂这句话，作者写这句话时感觉语法有些随意，上下文也不是很丰富与连贯，所以我也不清楚作者想要表达什么？比如，一种口服的药物被立即静脉输液？一个口服，转移室给药，并附加一个立即的静脉输液？】） "],["第十三章高级和其他主题.html", "第十三章高级和其他主题 13.1rxode2中的协变量 13.2Shiny与rxode2 13.3将rxode2与管道一起使用 13.4加速rxode2 13.5在您的包中集成rxode2模型 13.6具有雅可比规范的刚性ODE", " 第十三章高级和其他主题 这包括高级或杂项主题在rxode2 13.1rxode2中的协变量 13.1.1个体的协变量 如果您希望求解个体的协变量，您可以通过iCov数据集指定它： library(rxode2) library(units) library(xgxr) mod3 &lt;- rxode2({ KA=2.94E-01; #### Clearance with individuals CL=1.86E+01 * (WT / 70) ^ 0.75; V2=4.02E+01; Q=1.05E+01; V3=2.97E+02; Kin=1; Kout=1; EC50=200; #### The linCmt() picks up the variables from above C2 = linCmt(); Tz= 8 amp=0.1 eff(0) = 1 ## This specifies that the effect compartment starts at 1. d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; }) ev &lt;- et(amount.units=&quot;mg&quot;, time.units=&quot;hours&quot;) %&gt;% et(amt=10000, cmt=1) %&gt;% et(0,48,length.out=100) %&gt;% et(id=1:4); set.seed(10) rxSetSeed(10) #### Now use iCov to simulate a 4-id sample r1 &lt;- solve(mod3, ev, ### Create individual covariate data-frame iCov=data.frame(id=1:4, WT=rnorm(4, 70, 10))) print(r1) #&gt; -- Solved rxode2 object -- #&gt; -- Parameters ($params): -- #&gt; KA V2 Q V3 Kin Kout EC50 Tz amp #&gt; 0.294 40.200 10.500 297.000 1.000 1.000 200.000 8.000 0.100 #&gt; -- Initial Conditions ($inits): -- #&gt; eff #&gt; 1 #&gt; -- First part of data (object): -- #&gt; # A tibble: 400 x 6 #&gt; id time CL C2 eff WT #&gt; &lt;int&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 0 18.6 249. 1 70.2 #&gt; 2 1 0.485 18.6 175. 1 70.2 #&gt; 3 1 0.970 18.6 124. 1 70.2 #&gt; 4 1 1.45 18.6 87.9 1 70.2 #&gt; 5 1 1.94 18.6 62.7 1 70.2 #&gt; 6 1 2.42 18.6 45.1 1 70.2 #&gt; # ... with 394 more rows plot(r1, C2, log=&quot;y&quot;) 13.1.2随时间变化的协变量 协变量在rxode2中很容易指定，您可以将它们指定为变量。随时间变化的协变量，如昼夜节律模型中的时钟时间，也可以使用。扩展已讨论过的间接效应模型，我们有： library(rxode2) library(units) mod3 &lt;- rxode2({ KA=2.94E-01; CL=1.86E+01; V2=4.02E+01; Q=1.05E+01; V3=2.97E+02; Kin0=1; Kout=1; EC50=200; #### The linCmt() picks up the variables from above C2 = linCmt(); Tz= 8 amp=0.1 eff(0) = 1 ## This specifies that the effect compartment starts at 1. #### Kin changes based on time of day (like cortosol) Kin = Kin0 +amp *cos(2*pi*(ctime-Tz)/24) d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; }) ev &lt;- eventTable(amount.units=&quot;mg&quot;, time.units=&quot;hours&quot;) %&gt;% add.dosing(dose=10000, nbr.doses=1, dosing.to=1) %&gt;% add.sampling(seq(0,48,length.out=100)); #### Create data frame of 8 am dosing for the first dose This is done #### with base R but it can be done with dplyr or data.table ev$ctime &lt;- (ev$time+set_units(8,hr)) %% 24 现在事件数据集中存在一个协变量，系统可以通过结合数据集和模型来求解： r1 &lt;- solve(mod3, ev, covsInterpolation=&quot;linear&quot;) print(r1) #&gt; -- Solved rxode2 object -- #&gt; -- Parameters ($params): -- #&gt; KA CL V2 Q V3 Kin0 Kout #&gt; 0.294000 18.600000 40.200000 10.500000 297.000000 1.000000 1.000000 #&gt; EC50 Tz amp pi #&gt; 200.000000 8.000000 0.100000 3.141593 #&gt; -- Initial Conditions ($inits): -- #&gt; eff #&gt; 1 #&gt; -- First part of data (object): -- #&gt; # A tibble: 100 x 5 #&gt; time C2 Kin eff ctime #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; [h] #&gt; 1 0 249. 1.1 1 8 #&gt; 2 0.485 175. 1.10 1.04 8.48 #&gt; 3 0.970 124. 1.10 1.06 8.97 #&gt; 4 1.45 88.0 1.09 1.07 9.45 #&gt; 5 1.94 62.9 1.09 1.08 9.94 #&gt; 6 2.42 45.2 1.08 1.08 10.4 #&gt; # ... with 94 more rows 在求解ODE方程时，对数据之外的时间进行采样。发生这种情况时，此 ODE 求解器可以在协变量值之间使用线性插值。它等价于 R的approxfun函数的method=\"linear\"。【译者注：即这里的covsInterpolation参数项用于指定随时间变化的协变量，如何在观测的时间点进行填补】 plot(r1,C2, ylab=&quot;Central Concentration&quot;) plot(r1,eff) + ylab(&quot;Effect&quot;) + xlab(&quot;Time&quot;) 请注意，在这种情况下，线性近似会导致求解系统在24小时内出现一些问题，其中协变量在24小时附近和0附近之间具有线性插值。虽然线性似乎是合理的，但时钟时间等情况使其他插值方法更具吸引力。 在rxode2中，默认协变量插值是最后一个观测结果向前结转（locf,Last Observation Carries Forward），或常数逼近。这是相当于R的approxfun与method=\"constant\"。 r1 &lt;- solve(mod3, ev,covsInterpolation=&quot;locf&quot;) print(r1) #&gt; -- Solved rxode2 object -- #&gt; -- Parameters ($params): -- #&gt; KA CL V2 Q V3 Kin0 Kout #&gt; 0.294000 18.600000 40.200000 10.500000 297.000000 1.000000 1.000000 #&gt; EC50 Tz amp pi #&gt; 200.000000 8.000000 0.100000 3.141593 #&gt; -- Initial Conditions ($inits): -- #&gt; eff #&gt; 1 #&gt; -- First part of data (object): -- #&gt; # A tibble: 100 x 5 #&gt; time C2 Kin eff ctime #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; [h] #&gt; 1 0 249. 1.1 1 8 #&gt; 2 0.485 175. 1.10 1.04 8.48 #&gt; 3 0.970 124. 1.10 1.06 8.97 #&gt; 4 1.45 88.0 1.09 1.08 9.45 #&gt; 5 1.94 62.9 1.09 1.08 9.94 #&gt; 6 2.42 45.2 1.08 1.08 10.4 #&gt; # ... with 94 more rows 给出了以下图表： plot(r1,C2, ylab=&quot;Central Concentration&quot;, xlab=&quot;Time&quot;) plot(r1,eff, ylab=&quot;Effect&quot;, xlab=&quot;Time&quot;) 在这种情况下，图中的曲线似乎更流畅。 您还可以使用NONMEM风格默认的的下一个观测结果向后结转（NOCB，next observation carried backward）的插值样式： r1 &lt;- solve(mod3, ev,covsInterpolation=&quot;nocb&quot;) print(r1) #&gt; -- Solved rxode2 object -- #&gt; -- Parameters ($params): -- #&gt; KA CL V2 Q V3 Kin0 Kout #&gt; 0.294000 18.600000 40.200000 10.500000 297.000000 1.000000 1.000000 #&gt; EC50 Tz amp pi #&gt; 200.000000 8.000000 0.100000 3.141593 #&gt; -- Initial Conditions ($inits): -- #&gt; eff #&gt; 1 #&gt; -- First part of data (object): -- #&gt; # A tibble: 100 x 5 #&gt; time C2 Kin eff ctime #&gt; [h] &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; [h] #&gt; 1 0 249. 1.1 1 8 #&gt; 2 0.485 175. 1.10 1.04 8.48 #&gt; 3 0.970 124. 1.10 1.06 8.97 #&gt; 4 1.45 88.0 1.09 1.07 9.45 #&gt; 5 1.94 62.9 1.09 1.08 9.94 #&gt; 6 2.42 45.2 1.08 1.08 10.4 #&gt; # ... with 94 more rows 给出了以下图表： plot(r1,C2, ylab=&quot;Central Concentration&quot;, xlab=&quot;Time&quot;) plot(r1,eff, ylab=&quot;Effect&quot;, xlab=&quot;Time&quot;) 13.2Shiny与rxode2 13.2.1制作R Shiny应用的工具 创建一个示例 RShiny应用程序以交互方式探索各种复杂给药方案的反应的示例可在 http://qsp.engr.uga.edu:3838/rxode2/RegimenSimulator中找到。像这样的Shiny应用程序可以通过可以使用实验函数`genShinyApp.template()`以编程方式创建。 上述应用包括用于改变给药剂量、给药方案、剂量循环和循环次数的小部件。 genShinyApp.template(appDir = &quot;shinyExample&quot;, verbose=TRUE) library(shiny) runApp(&quot;shinyExample&quot;) 单击此处转到Shiny应用程序 13.2.2使用shiny以图形方式探索参数拟合 rxode2对象可以使用rxShiny(obj)进行探索。rxShiny()还允许您尝试新的模型，以了解它们的行为。 13.3将rxode2与管道一起使用 13.3.1为管道设置rxode2模型 在这个例子中，我们将展示如何在一个简单的管道中使用rxode2。 我们可以从一个模型开始，该模型可用于rxode2可以处理的不同模拟工作流： library(rxode2) Ribba2012 &lt;- rxode2({ k = 100 tkde = 0.24 eta.tkde = 0 kde ~ tkde*exp(eta.tkde) tkpq = 0.0295 eta.kpq = 0 kpq ~ tkpq * exp(eta.kpq) tkqpp = 0.0031 eta.kqpp = 0 kqpp ~ tkqpp * exp(eta.kqpp) tlambdap = 0.121 eta.lambdap = 0 lambdap ~ tlambdap*exp(eta.lambdap) tgamma = 0.729 eta.gamma = 0 gamma ~ tgamma*exp(eta.gamma) tdeltaqp = 0.00867 eta.deltaqp = 0 deltaqp ~ tdeltaqp*exp(eta.deltaqp) prop.err &lt;- 0 pstar &lt;- (pt+q+qp)*(1+prop.err) d/dt(c) = -kde * c d/dt(pt) = lambdap * pt *(1-pstar/k) + kqpp*qp - kpq*pt - gamma*c*kde*pt d/dt(q) = kpq*pt -gamma*c*kde*q d/dt(qp) = gamma*c*kde*q - kqpp*qp - deltaqp*qp #### initial conditions tpt0 = 7.13 eta.pt0 = 0 pt0 ~ tpt0*exp(eta.pt0) tq0 = 41.2 eta.q0 = 0 q0 ~ tq0*exp(eta.q0) pt(0) = pt0 q(0) = q0 }) 这是在Ribba 2012中描述的肿瘤生长模型。在这种情况下，我们将模型编译成R对象Ribba2012，尽管在rxode2模拟管道中，您不必将编译后的模型分配给任何对象，尽管我认为这是有意义的。 13.3.2模拟一个事件表 模拟单个事件表非常简单： 通过et()可以将rxode2模拟对象通过管道传输到事件表对象。 当完全指定事件时，您只需使用 rxSolve()求解 ODE 系统即可。 在这种情况下，您可以将输出通过管道传输到plot()以方便地查看结果。 pt（增殖组织）， q（静止组织） qp（DNA损伤的静止组织）和 pstar（肿瘤组织总数） Ribba2012 %&gt;% # Use rxode2 et(time.units=&quot;months&quot;) %&gt;% # Pipe to a new event table et(amt=1, time=50, until=58, ii=1.5) %&gt;% # Add dosing every 1.5 months et(0, 250, by=0.5) %&gt;% # Add some sampling times (not required) rxSolve() %&gt;% # Solve the simulation plot(pt, q, qp, pstar) # Plot it, plotting the variables of interest 13.3.3从单个事件表模拟多个个体 13.3.3.1模拟个体之间的变异 下一种可能有用的模拟是，模拟接受相同治疗的多个患者。在这种情况下，我们将使用文本规定 omega矩阵： #### Add CVs from paper for individual simulation #### Uses exact formula: lognCv = function(x){log((x/100)^2+1)} library(lotri) #### Now create omega matrix #### I&#39;m using lotri to quickly specify names/diagonals omega &lt;- lotri(eta.pt0 ~ lognCv(94), eta.q0 ~ lognCv(54), eta.lambdap ~ lognCv(72), eta.kqp ~ lognCv(76), eta.qpp ~ lognCv(97), eta.deltaqp ~ lognCv(115), eta.kde ~ lognCv(70)) omega #&gt; eta.pt0 eta.q0 eta.lambdap eta.kqp eta.qpp eta.deltaqp #&gt; eta.pt0 0.6331848 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #&gt; eta.q0 0.0000000 0.2558818 0.0000000 0.0000000 0.0000000 0.0000000 #&gt; eta.lambdap 0.0000000 0.0000000 0.4176571 0.0000000 0.0000000 0.0000000 #&gt; eta.kqp 0.0000000 0.0000000 0.0000000 0.4559047 0.0000000 0.0000000 #&gt; eta.qpp 0.0000000 0.0000000 0.0000000 0.0000000 0.6631518 0.0000000 #&gt; eta.deltaqp 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.8426442 #&gt; eta.kde 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 #&gt; eta.kde #&gt; eta.pt0 0.0000000 #&gt; eta.q0 0.0000000 #&gt; eta.lambdap 0.0000000 #&gt; eta.kqp 0.0000000 #&gt; eta.qpp 0.0000000 #&gt; eta.deltaqp 0.0000000 #&gt; eta.kde 0.3987761 有了这些信息，很容易从基于模型的参数中模拟3个主题： set.seed(1089) rxSetSeed(1089) Ribba2012 %&gt;% # Use rxode2 et(time.units=&quot;months&quot;) %&gt;% # Pipe to a new event table et(amt=1, time=50, until=58, ii=1.5) %&gt;% # Add dosing every 1.5 months et(0, 250, by=0.5) %&gt;% # Add some sampling times (not required) rxSolve(nSub=3, omega=omega) %&gt;% # Solve the simulation plot(pt, q, qp, pstar) # Plot it, plotting the variables of interest 请注意，此模拟中添加了两种不同的内容： -nSub指定模型中有多少个个体 -omega指定个体之间的变异。 13.3.3.2具有无法解释的变异【残差变异】的模拟 您甚至可以很容易地添加无法解释的变异【译者注：这里无法解释的变异是指残差变异】： Ribba2012 %&gt;% # Use rxode2 et(time.units=&quot;months&quot;) %&gt;% # Pipe to a new event table et(amt=1, time=50, until=58, ii=1.5) %&gt;% # Add dosing every 1.5 months et(0, 250, by=0.5) %&gt;% # Add some sampling times (not required) rxSolve(nSub=3, omega=omega, sigma=lotri(prop.err ~ 0.05^2)) %&gt;% # Solve the simulation plot(pt, q, qp, pstar) # Plot it, plotting the variables of interest 在此示例中，我们仅通过添加sigma矩阵以在pstar或总的肿瘤组织上添加无法解释的变异【译者注：这里无法解释的变异是指残差变异】。 如果你愿意，你甚至可以模拟theta omega和sigma值的不确定性。 13.3.3.3所有参数的不确定性模拟（按矩阵） 如果我们假设这些参数来自95受试者，每个受试者有 8 个观测结果，那么 omega 矩阵的自由度将为95，sigma矩阵的自由度是 95*8=760，因为95项通知(informed)了omega矩阵，而760 项通知sigma矩阵。 Ribba2012 %&gt;% # Use rxode2 et(time.units=&quot;months&quot;) %&gt;% # Pipe to a new event table et(amt=1, time=50, until=58, ii=1.5) %&gt;% # Add dosing every 1.5 months et(0, 250, by=0.5) %&gt;% # Add some sampling times (not required) rxSolve(nSub=3, nStud=3, omega=omega, sigma=lotri(prop.err ~ 0.05^2), dfSub=760, dfObs=95) %&gt;% # Solve the simulation plot(pt, q, qp, pstar) # Plot it, plotting the variables of interest 通常在模拟中，我们有一个固定效应参数的完整协方差矩阵。在此示例中，我们没有此矩阵，但它可以通过thetaMat指定。 虽然我们没有完整的协方差矩阵，但我们可以从模型论文中获得有关协方差矩阵对角线元素的信息。这些可以转换如下： rseVar &lt;- function(est, rse){ return(est*rse/100)^2 } thetaMat &lt;- lotri(tpt0 ~ rseVar(7.13,25), tq0 ~ rseVar(41.2,7), tlambdap ~ rseVar(0.121, 16), tkqpp ~ rseVar(0.0031, 35), tdeltaqp ~ rseVar(0.00867, 21), tgamma ~ rseVar(0.729, 37), tkde ~ rseVar(0.24, 33) ); thetaMat #&gt; tpt0 tq0 tlambdap tkqpp tdeltaqp tgamma tkde #&gt; tpt0 1.7825 0.000 0.00000 0.000000 0.0000000 0.00000 0.0000 #&gt; tq0 0.0000 2.884 0.00000 0.000000 0.0000000 0.00000 0.0000 #&gt; tlambdap 0.0000 0.000 0.01936 0.000000 0.0000000 0.00000 0.0000 #&gt; tkqpp 0.0000 0.000 0.00000 0.001085 0.0000000 0.00000 0.0000 #&gt; tdeltaqp 0.0000 0.000 0.00000 0.000000 0.0018207 0.00000 0.0000 #&gt; tgamma 0.0000 0.000 0.00000 0.000000 0.0000000 0.26973 0.0000 #&gt; tkde 0.0000 0.000 0.00000 0.000000 0.0000000 0.00000 0.0792 现在我们有一个thetaMat来表示theta矩阵中的不确定性，以及模拟中的其他部分。您可以使用thetaMat 矩阵将这些信息放入您的模拟中。 由于theta的变异很大，很容易抽样出一个负速率常数，这是没有意义的。例如： Ribba2012 %&gt;% # Use rxode2 et(time.units=&quot;months&quot;) %&gt;% # Pipe to a new event table et(amt=1, time=50, until=58, ii=1.5) %&gt;% # Add dosing every 1.5 months et(0, 250, by=0.5) %&gt;% # Add some sampling times (not required) rxSolve(nSub=2, nStud=2, omega=omega, sigma=lotri(prop.err ~ 0.05^2), thetaMat=thetaMat, dfSub=760, dfObs=95) %&gt;% # Solve the simulation plot(pt, q, qp, pstar) # Plot it, plotting the variables of interest #&gt; unhandled error message: EE:[lsoda] 70000 steps taken before reaching tout #&gt; @(lsoda.c:750 #&gt; Warning message: #&gt; In rxSolve_(object, .ctl, .nms, .xtra, params, events, inits, setupOnly = .setupOnly) : #&gt; Some ID(s) could not solve the ODEs correctly; These values are replaced with NA. 要纠正这些问题，您只需使用截断的多元正态并指定合理的参数范围。对于theta，这由thetaLower和 thetaUpper指定。其他矩阵也有类似的参数： omegaLower，omegaUpper，sigmaLower和sigmaUpper。这些可以是命名向量、一个数值或与thetaMat矩阵中指定的参数数量匹配的数字向量。 在此此示例中，只需修改模拟即可使 thetaLower=0，以确保所有速率都是正数的： Ribba2012 %&gt;% # Use rxode2 et(time.units=&quot;months&quot;) %&gt;% # Pipe to a new event table et(amt=1, time=50, until=58, ii=1.5) %&gt;% # Add dosing every 1.5 months et(0, 250, by=0.5) %&gt;% # Add some sampling times (not required) rxSolve(nSub=2, nStud=2, omega=omega, sigma=lotri(prop.err ~ 0.05^2), thetaMat=thetaMat, thetaLower=0, # Make sure the rates are reasonable dfSub=760, dfObs=95) %&gt;% # Solve the simulation plot(pt, q, qp, pstar) # Plot it, plotting the variables of interest 13.3.4总结模拟的输出 您不仅可以很容易的使用dplyr和data.table来执行自己的模拟的总结，也可以通过使用rxode2的 confint函数。 #### This takes a little more time; Most of the time is the summary #### time. sim0 &lt;- Ribba2012 %&gt;% # Use rxode2 et(time.units=&quot;months&quot;) %&gt;% # Pipe to a new event table et(amt=1, time=50, until=58, ii=1.5) %&gt;% # Add dosing every 1.5 months et(0, 250, by=0.5) %&gt;% # Add some sampling times (not required) rxSolve(nSub=10, nStud=10, omega=omega, sigma=lotri(prop.err ~ 0.05^2), thetaMat=thetaMat, thetaLower=0, # Make sure the rates are reasonable dfSub=760, dfObs=95) %&gt;% # Solve the simulation confint(c(&quot;pt&quot;,&quot;q&quot;,&quot;qp&quot;,&quot;pstar&quot;),level=0.90); # Create Simulation intervals sim0 %&gt;% plot() # Plot the simulation intervals 13.3.4.1从参数的数据框进行模拟 虽然从矩阵模拟可能非常有用并且是模拟信息的一种快速方法，但有时您可能想要模拟更复杂的场景。例如，可能有一些理由认为tkde需要高于tlambdap，因此需要更仔细地进行模拟。您可以以任何您想要的方式生成数据框。给出了模拟新参数的内部方法。 library(dplyr) pars &lt;- rxInits(Ribba2012); pars &lt;- pars[regexpr(&quot;(prop|eta)&quot;,names(pars)) == -1] print(pars) #&gt; k tkde tkpq tkqpp tlambdap tgamma tdeltaqp tpt0 #&gt; 1.00E+02 2.40E-01 2.95E-02 3.10E-03 1.21E-01 7.29E-01 8.67E-03 7.13E+00 #&gt; tq0 #&gt; 4.12E+01 #### This is the exported method for simulation of Theta/Omega internally in rxode2 df &lt;- rxSimThetaOmega(params=pars, omega=omega,dfSub=760, thetaMat=thetaMat, thetaLower=0, nSub=60,nStud=60) %&gt;% filter(tkde &gt; tlambdap) %&gt;% as.tbl() #### You could also simulate more and bind them together to a data frame. print(df) #&gt; # A tibble: 2,220 x 16 #&gt; k tkde tkpq tkqpp tlambdap tgamma tdeltaqp tpt0 tq0 eta.pt0 eta.q0 #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 100 0.341 0.0295 1.03 0.315 1.05 1.06 7.91 41.4 -0.0615 -0.170 #&gt; 2 100 0.341 0.0295 1.03 0.315 1.05 1.06 7.91 41.4 1.22 0.300 #&gt; 3 100 0.341 0.0295 1.03 0.315 1.05 1.06 7.91 41.4 0.487 0.850 #&gt; 4 100 0.341 0.0295 1.03 0.315 1.05 1.06 7.91 41.4 -0.660 -0.298 #&gt; 5 100 0.341 0.0295 1.03 0.315 1.05 1.06 7.91 41.4 0.608 0.135 #&gt; 6 100 0.341 0.0295 1.03 0.315 1.05 1.06 7.91 41.4 -1.70 0.0789 #&gt; 7 100 0.341 0.0295 1.03 0.315 1.05 1.06 7.91 41.4 -0.521 0.411 #&gt; 8 100 0.341 0.0295 1.03 0.315 1.05 1.06 7.91 41.4 0.630 -0.526 #&gt; 9 100 0.341 0.0295 1.03 0.315 1.05 1.06 7.91 41.4 -0.102 -0.617 #&gt; 10 100 0.341 0.0295 1.03 0.315 1.05 1.06 7.91 41.4 0.0731 -0.0867 #&gt; # ... with 2,210 more rows, and 5 more variables: eta.lambdap &lt;dbl&gt;, #&gt; # eta.kqp &lt;dbl&gt;, eta.qpp &lt;dbl&gt;, eta.deltaqp &lt;dbl&gt;, eta.kde &lt;dbl&gt; #### Quick check to make sure that all the parameters are OK. all(df$tkde&gt;df$tlambdap) #&gt; [1] TRUE sim1 &lt;- Ribba2012 %&gt;% # Use rxode2 et(time.units=&quot;months&quot;) %&gt;% # Pipe to a new event table et(amt=1, time=50, until=58, ii=1.5) %&gt;% # Add dosing every 1.5 months et(0, 250, by=0.5) %&gt;% # Add some sampling times (not required) rxSolve(df) #### Note this information looses information about which ID is in a #### &quot;study&quot;, so it summarizes the confidence intervals by dividing the #### subjects into sqrt(#subjects) subjects and then summarizes the #### confidence intervals sim2 &lt;- sim1 %&gt;% confint(c(&quot;pt&quot;,&quot;q&quot;,&quot;qp&quot;,&quot;pstar&quot;),level=0.90); # Create Simulation intervals save(sim2, file = file.path(system.file(package = &quot;rxode2&quot;), &quot;pipeline-sim2.rds&quot;), version = 2) sim2 %&gt;% plot() 13.4加速rxode2 13.4.1通过多个个体并行求解提高rxode2速度 rxode2最初是作为ODE解算器开发的，它允许对单个个体进行ODE解算。这种灵活性仍然受到支持。 来自rxode2教程的原始代码如下： library(rxode2) library(microbenchmark) library(ggplot2) mod1 &lt;- rxode2({ C2 = centr/V2; C3 = peri/V3; d/dt(depot) = -KA*depot; d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; eff(0) = 1 }) #### Create an event table ev &lt;- et() %&gt;% et(amt=10000, addl=9,ii=12) %&gt;% et(time=120, amt=20000, addl=4, ii=24) %&gt;% et(0:240) ## Add Sampling nsub &lt;- 100 # 100 sub-problems sigma &lt;- matrix(c(0.09,0.08,0.08,0.25),2,2) # IIV covariance matrix mv &lt;- rxRmvn(n=nsub, rep(0,2), sigma) # Sample from covariance matrix CL &lt;- 7*exp(mv[,1]) V2 &lt;- 40*exp(mv[,2]) params.all &lt;- cbind(KA=0.3, CL=CL, V2=V2, Q=10, V3=300, Kin=0.2, Kout=0.2, EC50=8) 13.4.1.1for循环 编写代码实现下述示例的最慢方法是使用 for loop循环。在这个例子中，我们将它包含在一个函数中以比较用时。 runFor &lt;- function(){ res &lt;- NULL for (i in 1:nsub) { params &lt;- params.all[i,] x &lt;- mod1$solve(params, ev) ##Store results for effect compartment res &lt;- cbind(res, x[, &quot;eff&quot;]) } return(res) } 13.4.1.2通过apply类函数运行 一般来说，对于R，apply类型的函数比 for循环执行得更好，所以教程也建议采用此种方式增强速度 runSapply &lt;- function(){ res &lt;- apply(params.all, 1, function(theta) mod1$run(theta, ev)[, &quot;eff&quot;]) } 13.4.1.3使用单线程求解运行 您还可以让rxode2使用单线程求解同时求解所有个体，而无需在R中收集结果。 这里的数据输出略有不同，但仍然提供相同的信息： runSingleThread &lt;- function(){ solve(mod1, params.all, ev, cores=1)[,c(&quot;sim.id&quot;, &quot;time&quot;, &quot;eff&quot;)] } 13.4.1.42使用线程求解运行 rxode2支持多线程求解，所以另一种选择是有2 线程（在求解器的选项中称为cores，可以在rxControl()或rxSolve()中看到有关选项） 。 run2Thread &lt;- function(){ solve(mod1, params.all, ev, cores=2)[,c(&quot;sim.id&quot;, &quot;time&quot;, &quot;eff&quot;)] } 13.4.1.5比较所有方法的用时 现在是关键时刻，时机： bench &lt;- microbenchmark(runFor(), runSapply(), runSingleThread(),run2Thread()) print(bench) #&gt; Unit: milliseconds #&gt; expr min lq mean median uq #&gt; runFor() 1062.73099 1304.97351 1355.11433 1349.88837 1409.64603 #&gt; runSapply() 1133.98743 1300.32975 1346.84780 1331.50023 1382.29895 #&gt; runSingleThread() 53.90511 67.85757 86.31790 80.53222 105.34612 #&gt; run2Thread() 33.69476 37.82068 48.49613 53.49341 55.43786 #&gt; max neval #&gt; 1635.26890 100 #&gt; 1681.23364 100 #&gt; 118.88022 100 #&gt; 77.92788 100 autoplot(bench) 很明显，性能会有跳跃式的提升是发生在使用solve方法并将所有参数提供给rxode2进行求解时，而不是发生在使用for或sapply循环遍历每个个体的方式求解的时候。 应用于求解的内核/线程的数量也在求解中起作用。 我们可以使用以下代码进一步探索线程数： runThread &lt;- function(n){ solve(mod1, params.all, ev, cores=n)[,c(&quot;sim.id&quot;, &quot;time&quot;, &quot;eff&quot;)] } bench &lt;- eval(parse(text=sprintf(&quot;microbenchmark(%s)&quot;, paste(paste0(&quot;runThread(&quot;, seq(1, 2 * rxCores()),&quot;)&quot;), collapse=&quot;,&quot;)))) print(bench) #&gt; Unit: milliseconds #&gt; expr min lq mean median uq max neval #&gt; runThread(1) 54.89976 71.36315 79.28627 82.80764 85.94690 95.65980 100 #&gt; runThread(2) 35.10327 38.48158 42.47366 41.74052 45.67836 59.75624 100 #&gt; runThread(3) 26.82482 30.17348 34.41744 33.63812 37.57002 61.36881 100 #&gt; runThread(4) 23.07798 27.67149 31.32003 30.51574 33.99461 46.33631 100 #&gt; runThread(5) 30.47240 38.82789 41.69443 41.54031 44.78454 50.49672 100 #&gt; runThread(6) 29.35039 33.44060 37.02153 37.26839 39.14627 59.46520 100 #&gt; runThread(7) 26.93386 29.83401 33.55118 33.39193 35.98574 49.71733 100 #&gt; runThread(8) 25.42155 28.83314 32.05635 32.01850 34.66935 54.87643 100 autoplot(bench) 在速度与数量或内核之间可能存在一个合适的位置。系统类型（mac、linux、windows和/或处理器）、ODE求解的复杂性和个体的数量可能会影响这个任意数量的线程。4个线程是一个很好的数字，无需任何先验知识，因为现在大多数系统至少有4个线程（或2个处理器和4个线程）。 13.4.2一个现实生活中的例子 在实现某些并行求解之前，运行rxode2的最快的方法是使用lapply。这就是Rik Schoemaker创建nlmixr比较的数据集方式，但为更快完成的pkgdown网站自动构建的运行，它被简化了。 library(rxode2) library(data.table) #Define the rxode2 model ode1 &lt;- &quot; d/dt(abs) = -KA*abs; d/dt(centr) = KA*abs-(CL/V)*centr; C2=centr/V; &quot; #Create the rxode2 simulation object mod1 &lt;- rxode2(model = ode1) #Population parameter values on log-scale paramsl &lt;- c(CL = log(4), V = log(70), KA = log(1)) #make 10,000 subjects to sample from: nsubg &lt;- 300 # subjects per dose doses &lt;- c(10, 30, 60, 120) nsub &lt;- nsubg * length(doses) #IIV of 30% for each parameter omega &lt;- diag(c(0.09, 0.09, 0.09))# IIV covariance matrix sigma &lt;- 0.2 #Sample from the multivariate normal set.seed(98176247) rxSetSeed(98176247) library(MASS) mv &lt;- mvrnorm(nsub, rep(0, dim(omega)[1]), omega) # Sample from covariance matrix #Combine population parameters with IIV params.all &lt;- data.table( &quot;ID&quot; = seq(1:nsub), &quot;CL&quot; = exp(paramsl[&#39;CL&#39;] + mv[, 1]), &quot;V&quot; = exp(paramsl[&#39;V&#39;] + mv[, 2]), &quot;KA&quot; = exp(paramsl[&#39;KA&#39;] + mv[, 3]) ) #set the doses (looping through the 4 doses) params.all[, AMT := rep(100 * doses,nsubg)] Startlapply &lt;- Sys.time() #Run the simulations using lapply for speed s = lapply(1:nsub, function(i) { #selects the parameters associated with the subject to be simulated params &lt;- params.all[i] #creates an eventTable with 7 doses every 24 hours ev &lt;- eventTable() ev$add.dosing( dose = params$AMT, nbr.doses = 1, dosing.to = 1, rate = NULL, start.time = 0 ) #generates 4 random samples in a 24 hour period ev$add.sampling(c(0, sort(round(sample(runif(600, 0, 1440), 4) / 60, 2)))) #runs the rxode2 simulation x &lt;- as.data.table(mod1$run(params, ev)) #merges the parameters and ID number to the simulation output x[, names(params) := params] }) #runs the entire sequence of 100 subjects and binds the results to the object res res = as.data.table(do.call(&quot;rbind&quot;, s)) Stoplapply &lt;- Sys.time() print(Stoplapply - Startlapply) #&gt; Time difference of 26.99468 secs 通过应用一些新的并行求解概念，您可以简单地以更少的代码和更快的速度运行相同的模拟： rx &lt;- rxode2({ CL = log(4) V = log(70) KA = log(1) CL = exp(CL + eta.CL) V = exp(V + eta.V) KA = exp(KA + eta.KA) d/dt(abs) = -KA*abs; d/dt(centr) = KA*abs-(CL/V)*centr; C2=centr/V; }) omega &lt;- lotri(eta.CL ~ 0.09, eta.V ~ 0.09, eta.KA ~ 0.09) doses &lt;- c(10, 30, 60, 120) startParallel &lt;- Sys.time() ev &lt;- do.call(&quot;rbind&quot;, lapply(seq_along(doses), function(i){ et() %&gt;% et(amt=doses[i]) %&gt;% # Add single dose et(0) %&gt;% # Add 0 observation #### Generate 4 samples in 24 hour period et(lapply(1:4, function(...){c(0, 24)})) %&gt;% et(id=seq(1, nsubg) + (i - 1) * nsubg) %&gt;% #### Convert to data frame to skip sorting the data #### When binding the data together as.data.frame })) #### To better compare, use the same output, that is data.table res &lt;- rxSolve(rx, ev, omega=omega, returnType=&quot;data.table&quot;) endParallel &lt;- Sys.time() print(endParallel - startParallel) #&gt; Time difference of 0.1851892 secs 您可以看到这两种方法之间的惊人时间差;要记住的几件事： rxode2使用线程安全的sitmothreefry例程来模拟eta 值。因此，预计结果会有所不同（此外，随机抽样的顺序也不同，因此会有所不同） 之前的模拟是在R 3.5中运行的，它具有不同的随机数生成器，因此当使用较慢的模拟时，此模拟中的结果将与实际的nlmixr比较不同。 这个速度比较使用了data.table.rxode2在内部使用data.table （如果可用）尝试加快排序速度，因此这在安装了data.table的与未安装的之间会存在不同。通过使用forderForceBase(TRUE)可以强制rxode2在排序时使用order() 。在这种情况下，两者之间几乎没有区别，尽管在其他示例中data.table的存在会导致速度提升（并且不太可能导致速度变慢）。 13.4.2.1想要通过更多的方法来运行多个体模拟 自教程发布以来的后续新版本有更多的方法来运行多个个体的模拟，包括使用et()（参见rxode2事件 如需更多信息）增加采样和给药时间的变异，能够同时提供omega和sigma 矩阵，以及通过添加thetaMat到R以模拟在omega，sigma和theta矩阵上的不确定性;见rxode2模拟插图。 13.5在您的包中集成rxode2模型 13.5.1在包中使用预编译模型 如果您计划开发一个R添加包，并希望将预编译的rxode2模型包含到您开发的R添加包中，这是可以很容易实现的。您只需用rxPkg()命令制作这个R添加包。 library(rxode2); #### Now Create a model idr &lt;- rxode2({ C2 = centr/V2; C3 = peri/V3; d/dt(depot) =-KA*depot; d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; }) #### You can specify as many models as you want to add rxPkg(idr, package=&quot;myPackage&quot;); ## Add the idr model to your package 上述操作将会： 将模型添加到您的R添加包中;一旦R添加包加载完成，您可以通过idr命令使用R添加包的数据 将正确的R添加包的需求添加到DESCRIPTION文件中。您需要更新此DESCRIPTION文件以描述包并修改作者、许可证等。 创建可以添加到R添加包文档中的骨架模型文档文件。在本例中，它将是R目录中的 idr-doc.R文件 创建一个configure和configure.win脚本，该脚本根据编译该脚本所依据的rxode2版本删除并重新生成src目录。如果您计划拥有自己编译的代码，应该对其进行修改，尽管我们并不建议这样做。 您可以在与rxode2对象交互的包中编写自己的R代码，以便您可以在包上下文中分发Shiny的应用程序和类似的东西。 一旦出现这种情况，您可以通过使用rxUse()将更多模型添加到您的R添加包中 。只需在您的R添加包中编译rxode2模型，然后用rxUse()添加该模型 rxUse(model) 现在model和idr模型库中了。这还将在您的R添加包目录中创建Model-doc.R，以便您可以记录该模型。 然后，您可以使用devtools方法来安装/测试您的模型 devtools::load_all() # Load all the functions in the package devtools::document() # Create package documentation devtools::install() # Install package devtools::check() # Check the package devtools::build() # build the package so you can submit it to places like CRAN 13.5.2在现有R添加包中使用模型 为了说明，让我们从一个空白的R添加包开始 library(rxode2) library(usethis) pkgPath &lt;- file.path(rxTempDir(),&quot;MyRxModel&quot;) create_package(pkgPath); use_gpl3_license(&quot;Matt&quot;) use_package(&quot;rxode2&quot;, &quot;LinkingTo&quot;) use_package(&quot;rxode2&quot;, &quot;Depends&quot;) ## library(rxode2) on load; Can use imports instead. use_roxygen_md() ##use_readme_md() library(rxode2); #### Now Create a model idr &lt;- rxode2({ C2 = centr/V2; C3 = peri/V3; d/dt(depot) =-KA*depot; d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3; d/dt(peri) = Q*C2 - Q*C3; d/dt(eff) = Kin - Kout*(1-C2/(EC50+C2))*eff; }); rxUse(idr); ## Add the idr model to your package rxUse(); # Update the compiled rxode2 sources for all of your packages 该rxUse()将： -创建rxode2源代码并将它们移动到包的src/ 目录。如果R添加包中只有R源代码，它还会用library-init.c结束目录，library-init.c中注册了R添加包中所有的rxode2模型，以便在R中使用。 -为您的R添加包中包含的每个模型创stub R文档。当您加载您的程序包时，您将能够通过标准的?接口R文档。 您仍然需要： -导出至少一个函数。如果您没有希望导出的函数，可以使用roxygen添加rxode2的再导出，示例如下： ##&#39; @importFrom rxode2 rxode2 ##&#39; @export rxode2::rxode2 如果您想在R添加包中使用Suggests而不是Depends， 您可能需要导出所有rxode2的标准例程【译者注：“routines”此处被翻译为”例程”，您可以将其理解为rxode2程序包的子程序】 ##&#39; @importFrom rxode2 rxode2 ##&#39; @export rxode2::rxode2 ##&#39; @importFrom rxode2 et ##&#39; @export rxode2::et ##&#39; @importFrom rxode2 etRep ##&#39; @export rxode2::etRep ##&#39; @importFrom rxode2 etSeq ##&#39; @export rxode2::etSeq ##&#39; @importFrom rxode2 as.et ##&#39; @export rxode2::as.et ##&#39; @importFrom rxode2 eventTable ##&#39; @export rxode2::eventTable ##&#39; @importFrom rxode2 add.dosing ##&#39; @export rxode2::add.dosing ##&#39; @importFrom rxode2 add.sampling ##&#39; @export rxode2::add.sampling ##&#39; @importFrom rxode2 rxSolve ##&#39; @export rxode2::rxSolve ##&#39; @importFrom rxode2 rxControl ##&#39; @export rxode2::rxControl ##&#39; @importFrom rxode2 rxClean ##&#39; @export rxode2::rxClean ##&#39; @importFrom rxode2 rxUse ##&#39; @export rxode2::rxUse ##&#39; @importFrom rxode2 rxShiny ##&#39; @export rxode2::rxShiny ##&#39; @importFrom rxode2 genShinyApp.template ##&#39; @export rxode2::genShinyApp.template ##&#39; @importFrom rxode2 cvPost ##&#39; @export rxode2::cvPost ### This is actually from `magrittr` but allows less imports ##&#39; @importFrom rxode2 %&gt;% ##&#39; @export rxode2::`%&gt;%` 您还需要指示R加载包含在模型dll中的模型库模型。这通过以下方式实现： ### In this case `rxModels` is the package name ##&#39; @useDynLib rxModels, .registration=TRUE 如果这是一个带有rxode2模型的R添加包，并且您不打算添加任何其他编译源（推荐），您可以添加以下配置脚本 #!/bin/sh ### This should be used for both configure and configure.win echo &quot;unlink(&#39;src&#39;, recursive=TRUE);rxode2::rxUse()&quot; &gt; build.R ${R_HOME}/bin/Rscript build.R rm build.R 根据check，您可能需要一个虚拟的autoconf脚本， #### dummy autoconf script #### It is saved to configure.ac 如果您想要与基于Rcpp或 C/Fortan的包中的其他源代码集成，则您需要包含rxModels-compiled.h和： -将定义宏compiledModelCall添加到注册列表中 .Call函数列表中。 -注册C接口以允许通过R_init0_rxModels_rxode2_models()进行模型求解（同样rxModels将被您换为您的R添加包的名称）。 完成后，您可以通过标准方法进行R添加包的编译/R添加包的文档生成： devtools::load_all() devtools::document() devtools::install() 如果您的R添加包在加载时使用了新版本的rxode2，则模型将在使用时重新编译。 但是，如果您希望为最新版本的 rxode2 重新编译模型，您只需在项目目录中再次调用rxUse()即可，然后使用安装/创建R添加包的标准方法。 devtools::load_all() devtools::document() devtools::install() 请注意，您不必包含生成模型所需的rxode2代码，即可在 src 目录中重新生成rxode2的C代码。与所有rxode2对象一样，summary将显示重新创建相同模型的一种方法。【译者注：这一段度的不太明白，有待实际操作后对这段的翻译进行修订】 一个已编译模型的R添加包的示例可以在 RXModels存储库中找到。 13.6具有雅可比规范的刚性ODE 13.6.0.1具有雅可比规范的刚性ODE 【译者注：如果你不感兴趣rxode2的具体实现原理，仅专注于基于rxode2的应用，您可以略过此章节。】 偶尔，您可能会遇到一个刚性微分方程(stiff differential equation)，这是一个在数值上不稳定的微分方程，参数的微小变化会导致ODEs的不同解。解决这个问题一种的方法是选择刚性求解器或混合刚性求解器 （就像默认的LSODA）。通常这就足够了。然而”精确的雅可比解(exact Jacobian solutions)“可能会增加ODE的稳定性。（注意，”雅可比矩阵(Jacobian)“是ODE规范关对每个变量的导数【译者注：你可以将其简单了理解为是导数矩阵】）。在rxode2中，您可以使用 df(状态)/dy(变量)=语句【译者注：即您可以使用此语句描述一个微分方程(导数方程)，并且允许您方程的等号左侧中的”谁(状态，比如中央室的药量)“相对于”谁(变量，比如时间，比如浓度等)“的导数，等于，”什么(即微分方程的右侧，您可以自编写方程的右侧的语句/公式)“】。在各种条件下具有刚性性质的经典常微分方程是范德波尔(Van der Pol)微分方程。 在rxode2中，这些可以通过以下方式指定： library(rxode2) Vtpol2 &lt;- rxode2({ d/dt(y) = dy d/dt(dy) = mu*(1-y^2)*dy - y ##### Jacobian df(y)/dy(dy) = 1 df(dy)/dy(y) = -2*dy*mu*y - 1 df(dy)/dy(dy) = mu*(1-y^2) ##### Initial conditions y(0) = 2 dy(0) = 0 ##### mu mu = 1 ## nonstiff; 10 moderately stiff; 1000 stiff }) et &lt;- eventTable(); et$add.sampling(seq(0, 10, length.out=200)); et$add.dosing(20, start.time=0); s1 &lt;- Vtpol2 %&gt;% solve(et, method=&quot;lsoda&quot;) print(s1) #&gt; -- Solved rxode2 object -- #&gt; -- Parameters ($params): -- #&gt; mu #&gt; 1 #&gt; -- Initial Conditions ($inits): -- #&gt; y dy #&gt; 2 0 #&gt; -- First part of data (object): -- #&gt; # A tibble: 200 x 3 #&gt; time y dy #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 22 0 #&gt; 2 0.0503 22.0 -0.0456 #&gt; 3 0.101 22.0 -0.0456 #&gt; 4 0.151 22.0 -0.0456 #&gt; 5 0.201 22.0 -0.0456 #&gt; 6 0.251 22.0 -0.0456 #&gt; # ... with 194 more rows 虽然在mu=1时并不刚性，但mu=1000是一个刚性的系统 s2 &lt;- Vtpol2 %&gt;% solve(c(mu=1000), et) print(s2) #&gt; -- Solved rxode2 object -- #&gt; -- Parameters ($params): -- #&gt; mu #&gt; 1000 #&gt; -- Initial Conditions ($inits): -- #&gt; y dy #&gt; 2 0 #&gt; -- First part of data (object): -- #&gt; # A tibble: 200 x 3 #&gt; time y dy #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 22 0 #&gt; 2 0.0503 22.0 -0.0000455 #&gt; 3 0.101 22.0 -0.0000455 #&gt; 4 0.151 22.0 -0.0000455 #&gt; 5 0.201 22.0 -0.0000455 #&gt; 6 0.251 22.0 -0.0000455 #&gt; # ... with 194 more rows 虽然这很容易做到，但有点乏味。如果你有适当的rxode2设置，你可以使用计算机代数系统符号来自动计算雅可比矩阵。 这是通过rxode2的calcJac选项完成的： Vtpol &lt;- rxode2({ d/dt(y) = dy d/dt(dy) = mu*(1-y^2)*dy - y ##### Initial conditions y(0) = 2 dy(0) = 0 ##### mu mu = 1 ## nonstiff; 10 moderately stiff; 1000 stiff }, calcJac=TRUE) 要查看生成的模型，可以使用rxCat()： &gt; rxCat(Vtpol) d/dt(y)=dy; d/dt(dy)=mu*(1-y^2)*dy-y; y(0)=2; dy(0)=0; mu=1; df(y)/dy(y)=0; df(dy)/dy(y)=-2*dy*mu*y-1; df(y)/dy(dy)=1; df(dy)/dy(dy)=mu*(-Rx_pow_di(y,2)+1); "]]
